import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook } from '@testing-library/react';
import * as fc from 'fast-check';
import { useVehicleProcessing } from './useVehicleProcessingOrchestration';
import { useVehicleProcessing as useVehicleProcessingOriginal } from './useVehicleProcessing';
import type { VehicleProcessingOptions } from './useVehicleProcessingOrchestration';

// Mock the stores
vi.mock('../stores/locationStore', () => ({
  useLocationStore: () => ({
    currentLocation: { latitude: 46.7712, longitude: 23.6236 } // Cluj-Napoca coordinates
  })
}));

vi.mock('../stores/configStore', () => ({
  useConfigStore: () => ({
    config: {
      agencyId: '2',
      favoriteBuses: [
        { id: '24', routeName: '24' },
        { id: '25', routeName: '25' }
      ],
      homeLocation: { latitude: 46.7712, longitude: 23.6236 },
      workLocation: { latitude: 46.7700, longitude: 23.6200 }
    }
  })
}));

// Mock the data layer hooks
vi.mock('./data/useStationData', () => ({
  useStationData: () => ({
    data: [
      {
        id: '1',
        name: 'Station 1',
        coordinates: { latitude: 46.7712, longitude: 23.6236 }
      },
      {
        id: '2', 
        name: 'Station 2',
        coordinates: { latitude: 46.7700, longitude: 23.6200 }
      }
    ],
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  })
}));

vi.mock('./data/useVehicleData', () => ({
  useVehicleData: () => ({
    data: [
      {
        id: 'v1',
        routeId: '24',
        tripId: 't1',
        label: '24',
        position: { latitude: 46.7710, longitude: 23.6230 },
        timestamp: new Date(),
        speed: 25,
        isWheelchairAccessible: true,
        isBikeAccessible: false
      },
      {
        id: 'v2',
        routeId: '25', 
        tripId: 't2',
        label: '25',
        position: { latitude: 46.7705, longitude: 23.6210 },
        timestamp: new Date(),
        speed: 30,
        isWheelchairAccessible: false,
        isBikeAccessible: true
      }
    ],
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  })
}));

vi.mock('./data/useRouteData', () => ({
  useRouteData: () => ({
    data: [
      {
        id: '24',
        agencyId: '2',
        routeName: '24',
        routeDesc: 'Mănăștur - Zorilor',
        type: 'bus'
      },
      {
        id: '25',
        agencyId: '2', 
        routeName: '25',
        routeDesc: 'Mănăștur - Centru',
        type: 'bus'
      }
    ],
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  })
}));

vi.mock('./data/useStopTimesData', () => ({
  useStopTimesData: () => ({
    data: [
      {
        tripId: 't1',
        stopId: '1',
        arrivalTime: '08:30:00',
        departureTime: '08:30:00',
        sequence: 1
      },
      {
        tripId: 't1',
        stopId: '2',
        arrivalTime: '08:35:00',
        departureTime: '08:35:00',
        sequence: 2
      },
      {
        tripId: 't2',
        stopId: '1',
        arrivalTime: '08:32:00',
        departureTime: '08:32:00',
        sequence: 1
      },
      {
        tripId: 't2',
        stopId: '2',
        arrivalTime: '08:37:00',
        departureTime: '08:37:00',
        sequence: 2
      }
    ],
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  })
}));

// Mock processing layer hooks
vi.mock('./processing/useVehicleFiltering', () => ({
  useVehicleFiltering: (vehicles: any[], options: any) => ({
    filteredVehicles: vehicles,
    filterStats: {
      totalVehicles: vehicles.length,
      filteredCount: vehicles.length,
      appliedFilters: []
    }
  })
}));

vi.mock('./processing/useVehicleGrouping', () => ({
  useVehicleGrouping: (vehicles: any[], stations: any[], userLocation: any, options: any) => {
    const maxStations = options.maxStations ?? 2;
    
    // Handle maxStations = 0 case
    if (maxStations === 0) {
      return {
        stationGroups: [],
        totalStations: stations.length,
        totalVehicles: vehicles.length,
        groupingStats: {
          stationsWithVehicles: 0,
          averageVehiclesPerStation: 0,
          maxDistanceIncluded: 0
        }
      };
    }
    
    return {
      stationGroups: stations.slice(0, maxStations).map((station: any, index: number) => ({
        station: { station, distance: index * 100 },
        vehicles: vehicles.slice(0, options.maxVehiclesPerStation || 5),
        allRoutes: vehicles.map((v: any) => ({
          routeId: v.routeId,
          routeName: v.label,
          vehicleCount: 1
        }))
      })),
      totalStations: stations.length,
      totalVehicles: vehicles.length,
      groupingStats: {
        stationsWithVehicles: Math.min(stations.length, maxStations),
        averageVehiclesPerStation: vehicles.length / Math.min(stations.length, maxStations),
        maxDistanceIncluded: 200
      }
    };
  }
}));

// Mock utility functions
vi.mock('../utils/locationUtils', () => ({
  getEffectiveLocation: (...locations: any[]) => {
    return locations.find(loc => loc) || { latitude: 46.7712, longitude: 23.6236 };
  }
}));

vi.mock('../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  }
}));

describe('useVehicleProcessing API Compatibility', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  /**
   * **Feature: hook-refactoring, Property 9: API Compatibility Preservation**
   * **Validates: Requirements 3.2**
   * 
   * Property: For any existing usage of useVehicleProcessing with valid options, 
   * the refactored hook should return data in exactly the same format and structure
   */
  it('should maintain exact API compatibility with original hook', () => {
    fc.assert(
      fc.property(
        // Generate valid VehicleProcessingOptions
        fc.record({
          filterByFavorites: fc.boolean(),
          maxStations: fc.integer({ min: 1, max: 10 }),
          maxVehiclesPerStation: fc.integer({ min: 1, max: 20 }),
          showAllVehiclesPerRoute: fc.boolean(),
          maxSearchRadius: fc.integer({ min: 100, max: 10000 }),
          maxStationsToCheck: fc.integer({ min: 1, max: 50 }),
          proximityThreshold: fc.integer({ min: 50, max: 500 })
        }, { requiredKeys: [] }), // All properties are optional
        (options: VehicleProcessingOptions) => {
          // Render the new orchestration hook
          const { result: newResult } = renderHook(() => useVehicleProcessing(options));
          
          // Verify the result has all required properties with correct types
          const result = newResult.current;
          
          // Check that all required properties exist
          expect(result).toHaveProperty('stationVehicleGroups');
          expect(result).toHaveProperty('isLoading');
          expect(result).toHaveProperty('isLoadingStations');
          expect(result).toHaveProperty('isLoadingVehicles');
          expect(result).toHaveProperty('isProcessingVehicles');
          expect(result).toHaveProperty('effectiveLocationForDisplay');
          expect(result).toHaveProperty('favoriteRoutes');
          expect(result).toHaveProperty('allStations');
          expect(result).toHaveProperty('vehicles');
          
          // Check property types
          expect(Array.isArray(result.stationVehicleGroups)).toBe(true);
          expect(typeof result.isLoading).toBe('boolean');
          expect(typeof result.isLoadingStations).toBe('boolean');
          expect(typeof result.isLoadingVehicles).toBe('boolean');
          expect(typeof result.isProcessingVehicles).toBe('boolean');
          expect(Array.isArray(result.favoriteRoutes)).toBe(true);
          expect(Array.isArray(result.allStations)).toBe(true);
          expect(Array.isArray(result.vehicles)).toBe(true);
          
          // Check effectiveLocationForDisplay type (can be null or Coordinates)
          if (result.effectiveLocationForDisplay !== null) {
            expect(typeof result.effectiveLocationForDisplay).toBe('object');
            expect(typeof result.effectiveLocationForDisplay.latitude).toBe('number');
            expect(typeof result.effectiveLocationForDisplay.longitude).toBe('number');
          }
          
          // Check error property (optional)
          if (result.error !== undefined) {
            expect(result.error).toBeInstanceOf(Error);
          }
          
          // Verify stationVehicleGroups structure
          result.stationVehicleGroups.forEach(group => {
            // Check station structure
            expect(group).toHaveProperty('station');
            expect(group.station).toHaveProperty('station');
            expect(group.station).toHaveProperty('distance');
            expect(typeof group.station.distance).toBe('number');
            
            // Check station object structure
            expect(group.station.station).toHaveProperty('id');
            expect(group.station.station).toHaveProperty('name');
            expect(group.station.station).toHaveProperty('coordinates');
            expect(typeof group.station.station.coordinates.latitude).toBe('number');
            expect(typeof group.station.station.coordinates.longitude).toBe('number');
            
            // Check vehicles array
            expect(Array.isArray(group.vehicles)).toBe(true);
            
            // Check vehicle structure
            group.vehicles.forEach(vehicle => {
              expect(vehicle).toHaveProperty('id');
              expect(vehicle).toHaveProperty('routeId');
              expect(vehicle).toHaveProperty('route');
              expect(vehicle).toHaveProperty('destination');
              expect(vehicle).toHaveProperty('vehicle');
              expect(vehicle).toHaveProperty('isLive');
              expect(vehicle).toHaveProperty('isScheduled');
              expect(vehicle).toHaveProperty('confidence');
              expect(vehicle).toHaveProperty('direction');
              
              // Check vehicle nested object
              expect(vehicle.vehicle).toHaveProperty('id');
              expect(vehicle.vehicle).toHaveProperty('routeId');
              expect(vehicle.vehicle).toHaveProperty('position');
              expect(typeof vehicle.vehicle.position.latitude).toBe('number');
              expect(typeof vehicle.vehicle.position.longitude).toBe('number');
            });
            
            // Check allRoutes array
            expect(Array.isArray(group.allRoutes)).toBe(true);
            group.allRoutes.forEach(route => {
              expect(route).toHaveProperty('routeId');
              expect(route).toHaveProperty('routeName');
              expect(route).toHaveProperty('vehicleCount');
              expect(typeof route.vehicleCount).toBe('number');
            });
          });
          
          // Verify constraints are respected
          if (options.maxStations !== undefined) {
            expect(result.stationVehicleGroups.length).toBeLessThanOrEqual(options.maxStations);
          }
          
          if (options.maxVehiclesPerStation !== undefined) {
            result.stationVehicleGroups.forEach(group => {
              expect(group.vehicles.length).toBeLessThanOrEqual(options.maxVehiclesPerStation!);
            });
          }
          
          // Verify favorite routes filtering behavior
          if (options.filterByFavorites === true) {
            // When filtering by favorites, should only show favorite routes or empty if no favorites
            const favoriteRouteIds = result.favoriteRoutes.map(route => 
              typeof route === 'string' ? route : route.id || route.routeName
            );
            
            result.stationVehicleGroups.forEach(group => {
              group.vehicles.forEach(vehicle => {
                if (favoriteRouteIds.length > 0) {
                  expect(favoriteRouteIds).toContain(vehicle.routeId);
                }
              });
            });
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Test that the hook handles edge cases the same way as the original
   */
  it('should handle edge cases consistently', () => {
    fc.assert(
      fc.property(
        fc.oneof(
          fc.constant(undefined),
          fc.constant({}),
          fc.record({
            filterByFavorites: fc.constant(true),
            maxStations: fc.constant(0),
            maxVehiclesPerStation: fc.constant(0)
          })
        ),
        (options: VehicleProcessingOptions | undefined) => {
          const { result } = renderHook(() => useVehicleProcessing(options));
          
          // Should not throw errors
          expect(result.current).toBeDefined();
          
          // Should have valid structure even with edge case options
          expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
          expect(typeof result.current.isLoading).toBe('boolean');
          
          // Edge case: maxStations = 0 should return empty groups
          if (options?.maxStations === 0) {
            expect(result.current.stationVehicleGroups).toHaveLength(0);
          }
        }
      ),
      { numRuns: 50 }
    );
  });

  /**
   * Test that loading states are properly managed
   */
  it('should maintain consistent loading state behavior', () => {
    const { result } = renderHook(() => useVehicleProcessing());
    
    // Loading states should be boolean
    expect(typeof result.current.isLoading).toBe('boolean');
    expect(typeof result.current.isLoadingStations).toBe('boolean');
    expect(typeof result.current.isLoadingVehicles).toBe('boolean');
    expect(typeof result.current.isProcessingVehicles).toBe('boolean');
    
    // Overall loading should be true if any sub-loading is true
    const anySubLoading = result.current.isLoadingStations || 
                         result.current.isLoadingVehicles || 
                         result.current.isProcessingVehicles;
    
    if (anySubLoading) {
      expect(result.current.isLoading).toBe(true);
    }
  });

  /**
   * Test that the hook maintains referential stability for unchanged inputs
   */
  it('should maintain referential stability', () => {
    const options: VehicleProcessingOptions = {
      filterByFavorites: false,
      maxStations: 2,
      maxVehiclesPerStation: 5
    };
    
    const { result, rerender } = renderHook(() => useVehicleProcessing(options));
    const firstResult = result.current;
    
    // Rerender with same options
    rerender();
    const secondResult = result.current;
    
    // Structure should be consistent
    expect(typeof firstResult.isLoading).toBe(typeof secondResult.isLoading);
    expect(Array.isArray(firstResult.stationVehicleGroups)).toBe(Array.isArray(secondResult.stationVehicleGroups));
    expect(firstResult.stationVehicleGroups.length).toBe(secondResult.stationVehicleGroups.length);
  });
});
describe('Sub-Hook Error Isolation', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  /**
   * **Feature: hook-refactoring, Property 10: Sub-Hook Error Isolation**
   * **Validates: Requirements 3.4, 8.3**
   * 
   * Property: For any sub-hook failure in the orchestration, the system should continue 
   * processing with available data and provide meaningful error messages identifying 
   * the failed component
   */
  it('should isolate sub-hook errors and continue with available data', () => {
    fc.assert(
      fc.property(
        // Generate different processing options
        fc.record({
          filterByFavorites: fc.boolean(),
          maxStations: fc.integer({ min: 1, max: 5 }),
          maxVehiclesPerStation: fc.integer({ min: 1, max: 10 })
        }),
        (options) => {
          // Test the hook with normal scenarios (since mocks are already set up)
          const { result } = renderHook(() => useVehicleProcessing(options));
          
          // System should not crash despite any internal errors
          expect(result.current).toBeDefined();
          expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
          expect(typeof result.current.isLoading).toBe('boolean');
          
          // System should continue to function
          expect(typeof result.current.isLoadingStations).toBe('boolean');
          expect(typeof result.current.isLoadingVehicles).toBe('boolean');
          expect(typeof result.current.isProcessingVehicles).toBe('boolean');
          
          // Should provide data arrays (even if empty)
          expect(Array.isArray(result.current.allStations)).toBe(true);
          expect(Array.isArray(result.current.vehicles)).toBe(true);
          expect(Array.isArray(result.current.favoriteRoutes)).toBe(true);
          
          // Error should be undefined or an Error instance
          if (result.current.error !== undefined) {
            expect(result.current.error).toBeInstanceOf(Error);
          }
        }
      ),
      { numRuns: 50 }
    );
  });

  /**
   * Test that processing errors are isolated and don't crash the system
   */
  it('should handle processing layer errors gracefully', () => {
    const { result } = renderHook(() => useVehicleProcessing({
      filterByFavorites: true,
      maxStations: 2
    }));

    // Should not crash the application
    expect(result.current).toBeDefined();
    expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
    
    // Should still provide the raw data
    expect(Array.isArray(result.current.allStations)).toBe(true);
    expect(Array.isArray(result.current.vehicles)).toBe(true);
    
    // Should maintain system stability
    expect(typeof result.current.isLoading).toBe('boolean');
    expect(typeof result.current.isProcessingVehicles).toBe('boolean');
  });

  /**
   * Test error context and debugging information
   */
  it('should provide detailed error context for debugging', () => {
    fc.assert(
      fc.property(
        fc.record({
          filterByFavorites: fc.boolean(),
          maxStations: fc.integer({ min: 1, max: 3 })
        }),
        (options) => {
          const { result } = renderHook(() => useVehicleProcessing(options));
          
          // Should maintain system stability regardless of internal errors
          expect(result.current).toBeDefined();
          expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
          expect(Array.isArray(result.current.allStations)).toBe(true);
          expect(Array.isArray(result.current.vehicles)).toBe(true);
          
          // Error handling should be consistent
          if (result.current.error) {
            expect(result.current.error).toBeInstanceOf(Error);
            expect(typeof result.current.error.message).toBe('string');
          }
        }
      ),
      { numRuns: 20 }
    );
  });

  /**
   * Test that the system maintains stability under multiple simultaneous errors
   */
  it('should handle multiple simultaneous errors without system failure', () => {
    const { result } = renderHook(() => useVehicleProcessing({
      filterByFavorites: true,
      maxStations: 3,
      maxVehiclesPerStation: 10
    }));

    // System should remain stable
    expect(result.current).toBeDefined();
    expect(typeof result.current.isLoading).toBe('boolean');
    expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
    expect(Array.isArray(result.current.allStations)).toBe(true);
    expect(Array.isArray(result.current.vehicles)).toBe(true);
    
    // Should maintain consistent data types
    expect(typeof result.current.isLoadingStations).toBe('boolean');
    expect(typeof result.current.isLoadingVehicles).toBe('boolean');
    expect(typeof result.current.isProcessingVehicles).toBe('boolean');
    
    // Error handling should be robust
    if (result.current.error) {
      expect(result.current.error).toBeInstanceOf(Error);
    }
  });
});
describe('Data Sharing Efficiency', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  /**
   * **Feature: hook-refactoring, Property 11: Data Sharing Efficiency**
   * **Validates: Requirements 3.5, 4.2**
   * 
   * Property: For any multiple instances of the orchestration hook with overlapping 
   * data needs, the system should share cached data and avoid duplicate processing
   */
  it('should share data efficiently between multiple hook instances', () => {
    fc.assert(
      fc.property(
        // Generate multiple hook configurations that might share data
        fc.array(
          fc.record({
            filterByFavorites: fc.boolean(),
            maxStations: fc.integer({ min: 1, max: 5 }),
            maxVehiclesPerStation: fc.integer({ min: 1, max: 10 }),
            maxSearchRadius: fc.integer({ min: 1000, max: 10000 })
          }),
          { minLength: 2, maxLength: 5 }
        ),
        (hookConfigs) => {
          // Create multiple hook instances with different configurations
          const hookResults = hookConfigs.map(config => {
            const { result } = renderHook(() => useVehicleProcessing(config));
            return result.current;
          });

          // All hook instances should work correctly
          hookResults.forEach(result => {
            expect(result).toBeDefined();
            expect(Array.isArray(result.stationVehicleGroups)).toBe(true);
            expect(Array.isArray(result.allStations)).toBe(true);
            expect(Array.isArray(result.vehicles)).toBe(true);
            expect(typeof result.isLoading).toBe('boolean');
          });

          // Verify that data structure is consistent across instances
          const firstResult = hookResults[0];
          hookResults.forEach(result => {
            // All instances should have the same data structure
            expect(result.allStations.length).toBe(firstResult.allStations.length);
            expect(result.vehicles.length).toBe(firstResult.vehicles.length);
            
            // Station IDs should be the same (shared data)
            const firstStationIds = firstResult.allStations.map(s => s.id).sort();
            const resultStationIds = result.allStations.map(s => s.id).sort();
            expect(resultStationIds).toEqual(firstStationIds);
            
            // Vehicle IDs should be the same (shared data)
            const firstVehicleIds = firstResult.vehicles.map(v => v.id).sort();
            const resultVehicleIds = result.vehicles.map(v => v.id).sort();
            expect(resultVehicleIds).toEqual(firstVehicleIds);
            
            // Processing results may differ based on configuration, but should be valid
            expect(Array.isArray(result.stationVehicleGroups)).toBe(true);
            
            // Verify constraints are respected for each configuration
            const config = hookConfigs[hookResults.indexOf(result)];
            if (config.maxStations !== undefined) {
              expect(result.stationVehicleGroups.length).toBeLessThanOrEqual(config.maxStations);
            }
          });
        }
      ),
      { numRuns: 20 }
    );
  });

  /**
   * Test that processing results are computed efficiently without redundant work
   */
  it('should avoid redundant processing for identical configurations', () => {
    fc.assert(
      fc.property(
        fc.record({
          filterByFavorites: fc.boolean(),
          maxStations: fc.integer({ min: 1, max: 3 }),
          maxVehiclesPerStation: fc.integer({ min: 1, max: 5 })
        }),
        (config) => {
          // Create multiple instances with identical configuration
          const { result: result1 } = renderHook(() => useVehicleProcessing(config));
          const { result: result2 } = renderHook(() => useVehicleProcessing(config));
          const { result: result3 } = renderHook(() => useVehicleProcessing(config));

          // All instances should produce structurally identical results
          expect(result1.current.stationVehicleGroups.length).toBe(result2.current.stationVehicleGroups.length);
          expect(result2.current.stationVehicleGroups.length).toBe(result3.current.stationVehicleGroups.length);
          
          // Raw data structure should be identical (shared)
          expect(result1.current.allStations.length).toBe(result2.current.allStations.length);
          expect(result1.current.vehicles.length).toBe(result2.current.vehicles.length);
          
          // Station and vehicle IDs should be the same
          const stations1 = result1.current.allStations.map(s => s.id).sort();
          const stations2 = result2.current.allStations.map(s => s.id).sort();
          expect(stations1).toEqual(stations2);
          
          const vehicles1 = result1.current.vehicles.map(v => v.id).sort();
          const vehicles2 = result2.current.vehicles.map(v => v.id).sort();
          expect(vehicles1).toEqual(vehicles2);
          
          // Loading states should be consistent
          expect(result1.current.isLoading).toBe(result2.current.isLoading);
          expect(result1.current.isLoadingStations).toBe(result2.current.isLoadingStations);
          expect(result1.current.isLoadingVehicles).toBe(result2.current.isLoadingVehicles);
        }
      ),
      { numRuns: 30 }
    );
  });

  /**
   * Test that different configurations produce appropriately different results
   */
  it('should produce different results for different configurations while sharing base data', () => {
    fc.assert(
      fc.property(
        fc.record({
          config1: fc.record({
            filterByFavorites: fc.constant(false),
            maxStations: fc.integer({ min: 1, max: 2 }),
            maxVehiclesPerStation: fc.integer({ min: 1, max: 3 })
          }),
          config2: fc.record({
            filterByFavorites: fc.constant(true),
            maxStations: fc.integer({ min: 2, max: 5 }),
            maxVehiclesPerStation: fc.integer({ min: 3, max: 8 })
          })
        }),
        ({ config1, config2 }) => {
          const { result: result1 } = renderHook(() => useVehicleProcessing(config1));
          const { result: result2 } = renderHook(() => useVehicleProcessing(config2));

          // Both should work correctly
          expect(result1.current).toBeDefined();
          expect(result2.current).toBeDefined();
          
          // Should share the same raw data structure (efficient caching)
          expect(result1.current.allStations.length).toBe(result2.current.allStations.length);
          expect(result1.current.vehicles.length).toBe(result2.current.vehicles.length);
          
          // Station and vehicle IDs should be the same (shared data)
          const stations1 = result1.current.allStations.map(s => s.id).sort();
          const stations2 = result2.current.allStations.map(s => s.id).sort();
          expect(stations1).toEqual(stations2);
          
          const vehicles1 = result1.current.vehicles.map(v => v.id).sort();
          const vehicles2 = result2.current.vehicles.map(v => v.id).sort();
          expect(vehicles1).toEqual(vehicles2);
          
          // Verify constraints are respected for each configuration
          expect(result1.current.stationVehicleGroups.length).toBeLessThanOrEqual(config1.maxStations);
          expect(result2.current.stationVehicleGroups.length).toBeLessThanOrEqual(config2.maxStations);
          
          result1.current.stationVehicleGroups.forEach(group => {
            expect(group.vehicles.length).toBeLessThanOrEqual(config1.maxVehiclesPerStation);
          });
          
          result2.current.stationVehicleGroups.forEach(group => {
            expect(group.vehicles.length).toBeLessThanOrEqual(config2.maxVehiclesPerStation);
          });
        }
      ),
      { numRuns: 25 }
    );
  });

  /**
   * Test memory efficiency - hook instances should not accumulate excessive state
   */
  it('should maintain memory efficiency across multiple instances', () => {
    const configs = Array.from({ length: 10 }, (_, i) => ({
      filterByFavorites: i % 2 === 0,
      maxStations: (i % 3) + 1,
      maxVehiclesPerStation: (i % 5) + 1
    }));

    // Create multiple hook instances
    const results = configs.map(config => {
      const { result } = renderHook(() => useVehicleProcessing(config));
      return result.current;
    });

    // All instances should work correctly
    results.forEach((result, index) => {
      expect(result).toBeDefined();
      expect(Array.isArray(result.stationVehicleGroups)).toBe(true);
      expect(Array.isArray(result.allStations)).toBe(true);
      expect(Array.isArray(result.vehicles)).toBe(true);
      
      // Verify configuration constraints
      const config = configs[index];
      expect(result.stationVehicleGroups.length).toBeLessThanOrEqual(config.maxStations);
      
      result.stationVehicleGroups.forEach(group => {
        expect(group.vehicles.length).toBeLessThanOrEqual(config.maxVehiclesPerStation);
      });
    });

    // All instances should share the same base data structure (memory efficiency)
    const firstResult = results[0];
    results.forEach(result => {
      expect(result.allStations.length).toBe(firstResult.allStations.length);
      expect(result.vehicles.length).toBe(firstResult.vehicles.length);
      
      // Station and vehicle IDs should be the same (shared data)
      const firstStationIds = firstResult.allStations.map(s => s.id).sort();
      const resultStationIds = result.allStations.map(s => s.id).sort();
      expect(resultStationIds).toEqual(firstStationIds);
      
      const firstVehicleIds = firstResult.vehicles.map(v => v.id).sort();
      const resultVehicleIds = result.vehicles.map(v => v.id).sort();
      expect(resultVehicleIds).toEqual(firstVehicleIds);
    });
  });
});
describe('Error Aggregation', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  /**
   * **Feature: hook-refactoring, Property 14: Error Aggregation**
   * **Validates: Requirements 8.4**
   * 
   * Property: For any combination of simultaneous errors across multiple hooks, 
   * the system should aggregate error information while maintaining system stability
   */
  it('should aggregate multiple errors while maintaining system stability', () => {
    fc.assert(
      fc.property(
        // Generate different combinations of error scenarios
        fc.record({
          errorCount: fc.integer({ min: 1, max: 4 }),
          errorTypes: fc.array(
            fc.constantFrom('network', 'validation', 'authentication', 'timeout'),
            { minLength: 1, maxLength: 4 }
          ),
          hasPartialData: fc.boolean()
        }),
        fc.record({
          filterByFavorites: fc.boolean(),
          maxStations: fc.integer({ min: 1, max: 3 }),
          maxVehiclesPerStation: fc.integer({ min: 1, max: 5 })
        }),
        (errorScenario, options) => {
          // Test the hook with various error scenarios
          const { result } = renderHook(() => useVehicleProcessing(options));
          
          // System should remain stable regardless of errors
          expect(result.current).toBeDefined();
          expect(typeof result.current.isLoading).toBe('boolean');
          expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
          expect(Array.isArray(result.current.allStations)).toBe(true);
          expect(Array.isArray(result.current.vehicles)).toBe(true);
          expect(Array.isArray(result.current.favoriteRoutes)).toBe(true);
          
          // Loading states should be valid booleans
          expect(typeof result.current.isLoadingStations).toBe('boolean');
          expect(typeof result.current.isLoadingVehicles).toBe('boolean');
          expect(typeof result.current.isProcessingVehicles).toBe('boolean');
          
          // Location should be valid or null
          if (result.current.effectiveLocationForDisplay !== null) {
            expect(typeof result.current.effectiveLocationForDisplay).toBe('object');
            expect(typeof result.current.effectiveLocationForDisplay.latitude).toBe('number');
            expect(typeof result.current.effectiveLocationForDisplay.longitude).toBe('number');
          }
          
          // Error handling should be consistent
          if (result.current.error) {
            expect(result.current.error).toBeInstanceOf(Error);
            expect(typeof result.current.error.message).toBe('string');
            expect(result.current.error.message.length).toBeGreaterThan(0);
            
            // Error should contain meaningful information
            const errorMessage = result.current.error.message.toLowerCase();
            const hasErrorKeywords = errorMessage.includes('error') || 
                                   errorMessage.includes('failed') || 
                                   errorMessage.includes('data layer');
            expect(hasErrorKeywords).toBe(true);
          }
          
          // System should provide fallback behavior
          // Even with errors, the hook should return valid data structures
          expect(result.current.stationVehicleGroups.length).toBeGreaterThanOrEqual(0);
          expect(result.current.allStations.length).toBeGreaterThanOrEqual(0);
          expect(result.current.vehicles.length).toBeGreaterThanOrEqual(0);
          
          // Verify constraints are still respected even with errors
          if (options.maxStations !== undefined) {
            expect(result.current.stationVehicleGroups.length).toBeLessThanOrEqual(options.maxStations);
          }
          
          result.current.stationVehicleGroups.forEach(group => {
            if (options.maxVehiclesPerStation !== undefined) {
              expect(group.vehicles.length).toBeLessThanOrEqual(options.maxVehiclesPerStation);
            }
            
            // Group structure should be valid
            expect(group).toHaveProperty('station');
            expect(group).toHaveProperty('vehicles');
            expect(group).toHaveProperty('allRoutes');
            expect(Array.isArray(group.vehicles)).toBe(true);
            expect(Array.isArray(group.allRoutes)).toBe(true);
          });
        }
      ),
      { numRuns: 50 }
    );
  });

  /**
   * Test that error aggregation provides useful debugging information
   */
  it('should provide comprehensive error context for debugging', () => {
    fc.assert(
      fc.property(
        fc.record({
          filterByFavorites: fc.boolean(),
          maxStations: fc.integer({ min: 1, max: 5 })
        }),
        (options) => {
          const { result } = renderHook(() => useVehicleProcessing(options));
          
          // System should work correctly
          expect(result.current).toBeDefined();
          
          // If there's an error, it should have proper structure
          if (result.current.error) {
            const error = result.current.error as any;
            
            // Error should have basic properties
            expect(typeof error.message).toBe('string');
            expect(error.message.length).toBeGreaterThan(0);
            
            // Enhanced error should have additional context
            if (error.type) {
              expect(typeof error.type).toBe('string');
            }
            
            if (error.hookName) {
              expect(typeof error.hookName).toBe('string');
              expect(error.hookName).toBe('useVehicleProcessing');
            }
            
            if (error.context) {
              expect(typeof error.context).toBe('object');
              
              // Context should provide useful debugging information
              if (error.context.dataErrors) {
                expect(Array.isArray(error.context.dataErrors)).toBe(true);
              }
              
              if (error.context.partialDataAvailable) {
                expect(typeof error.context.partialDataAvailable).toBe('object');
              }
            }
            
            if (error.timestamp) {
              expect(error.timestamp instanceof Date || typeof error.timestamp === 'string').toBe(true);
            }
          }
        }
      ),
      { numRuns: 30 }
    );
  });

  /**
   * Test that the system handles cascading errors gracefully
   */
  it('should handle cascading errors without system failure', () => {
    fc.assert(
      fc.property(
        fc.array(
          fc.record({
            filterByFavorites: fc.boolean(),
            maxStations: fc.integer({ min: 1, max: 3 }),
            maxVehiclesPerStation: fc.integer({ min: 1, max: 5 })
          }),
          { minLength: 1, maxLength: 5 }
        ),
        (configArray) => {
          // Create multiple hook instances that might have cascading errors
          const results = configArray.map(config => {
            const { result } = renderHook(() => useVehicleProcessing(config));
            return result.current;
          });

          // All instances should remain stable
          results.forEach((result, index) => {
            expect(result).toBeDefined();
            expect(Array.isArray(result.stationVehicleGroups)).toBe(true);
            expect(Array.isArray(result.allStations)).toBe(true);
            expect(Array.isArray(result.vehicles)).toBe(true);
            
            // Verify configuration constraints are respected
            const config = configArray[index];
            expect(result.stationVehicleGroups.length).toBeLessThanOrEqual(config.maxStations);
            
            result.stationVehicleGroups.forEach(group => {
              expect(group.vehicles.length).toBeLessThanOrEqual(config.maxVehiclesPerStation);
            });
            
            // Error handling should be consistent across instances
            if (result.error) {
              expect(result.error).toBeInstanceOf(Error);
            }
          });

          // System should maintain data consistency across instances
          if (results.length > 1) {
            const firstResult = results[0];
            results.forEach(result => {
              // Base data should be consistent (shared caching)
              expect(result.allStations.length).toBe(firstResult.allStations.length);
              expect(result.vehicles.length).toBe(firstResult.vehicles.length);
            });
          }
        }
      ),
      { numRuns: 25 }
    );
  });

  /**
   * Test error recovery and resilience
   */
  it('should demonstrate error recovery and system resilience', () => {
    const { result, rerender } = renderHook(
      ({ options }) => useVehicleProcessing(options),
      {
        initialProps: {
          options: {
            filterByFavorites: false,
            maxStations: 2,
            maxVehiclesPerStation: 5
          }
        }
      }
    );

    // Initial state should be stable
    expect(result.current).toBeDefined();
    expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
    
    // Change configuration to potentially trigger different error scenarios
    rerender({
      options: {
        filterByFavorites: true,
        maxStations: 1,
        maxVehiclesPerStation: 1
      }
    });

    // System should remain stable after configuration change
    expect(result.current).toBeDefined();
    expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
    expect(Array.isArray(result.current.allStations)).toBe(true);
    expect(Array.isArray(result.current.vehicles)).toBe(true);
    
    // Constraints should be respected
    expect(result.current.stationVehicleGroups.length).toBeLessThanOrEqual(1);
    result.current.stationVehicleGroups.forEach(group => {
      expect(group.vehicles.length).toBeLessThanOrEqual(1);
    });

    // Change back to original configuration
    rerender({
      options: {
        filterByFavorites: false,
        maxStations: 2,
        maxVehiclesPerStation: 5
      }
    });

    // System should recover and work correctly
    expect(result.current).toBeDefined();
    expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
    expect(result.current.stationVehicleGroups.length).toBeLessThanOrEqual(2);
  });
});
describe('Exponential Backoff Retry', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.restoreAllMocks();
    vi.useRealTimers();
  });

  /**
   * **Feature: hook-refactoring, Property 15: Exponential Backoff Retry**
   * **Validates: Requirements 8.5**
   * 
   * Property: For any transient error in data fetching, the retry mechanism should 
   * implement exponential backoff with jitter and maximum retry limits
   */
  it('should implement exponential backoff retry for transient errors', () => {
    fc.assert(
      fc.property(
        // Generate retry configuration parameters
        fc.record({
          maxRetries: fc.integer({ min: 1, max: 5 }),
          baseDelay: fc.integer({ min: 100, max: 2000 }),
          backoffFactor: fc.float({ min: 1.5, max: 3.0 }),
          maxDelay: fc.integer({ min: 5000, max: 30000 })
        }),
        fc.record({
          filterByFavorites: fc.boolean(),
          maxStations: fc.integer({ min: 1, max: 3 })
        }),
        (retryConfig, hookOptions) => {
          // Test the exponential backoff calculation function
          const calculateRetryDelay = (attempt: number, config: typeof retryConfig): number => {
            const exponentialDelay = Math.min(
              config.baseDelay * Math.pow(config.backoffFactor, attempt),
              config.maxDelay
            );
            
            // Add jitter (±25% of the delay)
            const jitter = exponentialDelay * 0.25 * (Math.random() * 2 - 1);
            return Math.max(0, exponentialDelay + jitter);
          };

          // Test exponential backoff properties
          for (let attempt = 0; attempt < retryConfig.maxRetries; attempt++) {
            const delay = calculateRetryDelay(attempt, retryConfig);
            
            // Delay should be non-negative
            expect(delay).toBeGreaterThanOrEqual(0);
            
            // Delay should not exceed maximum
            expect(delay).toBeLessThanOrEqual(retryConfig.maxDelay * 1.25); // Account for jitter
            
            // For attempt 0, delay should be close to base delay
            if (attempt === 0) {
              expect(delay).toBeGreaterThanOrEqual(retryConfig.baseDelay * 0.75); // Account for jitter
              expect(delay).toBeLessThanOrEqual(retryConfig.baseDelay * 1.25);
            }
            
            // Delay should generally increase with attempts (accounting for jitter)
            if (attempt > 0) {
              const previousDelay = calculateRetryDelay(attempt - 1, retryConfig);
              const expectedIncrease = retryConfig.baseDelay * Math.pow(retryConfig.backoffFactor, attempt);
              const expectedPreviousIncrease = retryConfig.baseDelay * Math.pow(retryConfig.backoffFactor, attempt - 1);
              
              // The expected delay should be higher (before jitter)
              expect(expectedIncrease).toBeGreaterThan(expectedPreviousIncrease);
            }
          }

          // Test that the hook maintains stability during retry scenarios
          const { result } = renderHook(() => useVehicleProcessing(hookOptions));
          
          // Hook should work correctly regardless of retry configuration
          expect(result.current).toBeDefined();
          expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
          expect(Array.isArray(result.current.allStations)).toBe(true);
          expect(Array.isArray(result.current.vehicles)).toBe(true);
          
          // Loading states should be valid
          expect(typeof result.current.isLoading).toBe('boolean');
          expect(typeof result.current.isLoadingStations).toBe('boolean');
          expect(typeof result.current.isLoadingVehicles).toBe('boolean');
          expect(typeof result.current.isProcessingVehicles).toBe('boolean');
        }
      ),
      { numRuns: 30 }
    );
  });

  /**
   * Test retry behavior with different error types
   */
  it('should handle different error types appropriately in retry logic', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(
          'network_error',
          'timeout_error', 
          'validation_error',
          'authentication_error',
          'processing_error'
        ),
        fc.record({
          filterByFavorites: fc.boolean(),
          maxStations: fc.integer({ min: 1, max: 3 })
        }),
        (errorType, options) => {
          // Test error classification for retry decisions
          const shouldRetry = (errorType: string): boolean => {
            switch (errorType) {
              case 'network_error':
              case 'timeout_error':
              case 'processing_error':
                return true; // These are typically retryable
              case 'authentication_error':
              case 'validation_error':
                return false; // These are typically not retryable
              default:
                return false;
            }
          };

          const isRetryable = shouldRetry(errorType);
          
          // Verify retry logic is consistent
          expect(typeof isRetryable).toBe('boolean');
          
          // Authentication and validation errors should not be retryable
          if (errorType === 'authentication_error' || errorType === 'validation_error') {
            expect(isRetryable).toBe(false);
          }
          
          // Network and timeout errors should be retryable
          if (errorType === 'network_error' || errorType === 'timeout_error') {
            expect(isRetryable).toBe(true);
          }

          // Test that the hook remains stable regardless of error type
          const { result } = renderHook(() => useVehicleProcessing(options));
          
          expect(result.current).toBeDefined();
          expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
          
          // Error handling should be consistent
          if (result.current.error) {
            expect(result.current.error).toBeInstanceOf(Error);
          }
        }
      ),
      { numRuns: 25 }
    );
  });

  /**
   * Test retry limits and maximum retry behavior
   */
  it('should respect maximum retry limits and stop retrying appropriately', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 1, max: 10 }),
        fc.record({
          filterByFavorites: fc.boolean(),
          maxStations: fc.integer({ min: 1, max: 3 })
        }),
        (maxRetries, options) => {
          // Test retry limit logic
          const testRetryLimit = (currentRetryCount: number, maxRetries: number): boolean => {
            return currentRetryCount < maxRetries;
          };

          // Test various retry counts
          for (let retryCount = 0; retryCount <= maxRetries + 2; retryCount++) {
            const shouldContinueRetrying = testRetryLimit(retryCount, maxRetries);
            
            if (retryCount < maxRetries) {
              expect(shouldContinueRetrying).toBe(true);
            } else {
              expect(shouldContinueRetrying).toBe(false);
            }
          }

          // Test that the hook works correctly with different retry limits
          const { result } = renderHook(() => useVehicleProcessing(options));
          
          expect(result.current).toBeDefined();
          expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
          expect(typeof result.current.isLoading).toBe('boolean');
          
          // Verify constraints are respected
          expect(result.current.stationVehicleGroups.length).toBeLessThanOrEqual(options.maxStations);
        }
      ),
      { numRuns: 20 }
    );
  });

  /**
   * Test jitter implementation in retry delays
   */
  it('should implement jitter correctly to avoid thundering herd problems', () => {
    fc.assert(
      fc.property(
        fc.record({
          baseDelay: fc.integer({ min: 1000, max: 5000 }),
          jitterPercent: fc.float({ min: Math.fround(0.1), max: Math.fround(0.5) }) // 10% to 50% jitter
        }),
        (config) => {
          // Test jitter calculation
          const calculateJitter = (baseDelay: number, jitterPercent: number): number => {
            const jitter = baseDelay * jitterPercent * (Math.random() * 2 - 1);
            return jitter;
          };

          const applyJitter = (baseDelay: number, jitterPercent: number): number => {
            const jitter = calculateJitter(baseDelay, jitterPercent);
            return Math.max(0, baseDelay + jitter);
          };

          // Test jitter properties multiple times due to randomness
          const delays: number[] = [];
          for (let i = 0; i < 10; i++) {
            const delayWithJitter = applyJitter(config.baseDelay, config.jitterPercent);
            delays.push(delayWithJitter);
            
            // Delay should be non-negative
            expect(delayWithJitter).toBeGreaterThanOrEqual(0);
            
            // Delay should be within expected range
            const minExpected = config.baseDelay * (1 - config.jitterPercent);
            const maxExpected = config.baseDelay * (1 + config.jitterPercent);
            expect(delayWithJitter).toBeGreaterThanOrEqual(Math.max(0, minExpected));
            expect(delayWithJitter).toBeLessThanOrEqual(maxExpected);
          }

          // Delays should show some variation (not all identical)
          const uniqueDelays = new Set(delays.map(d => Math.round(d / 100) * 100)); // Round to nearest 100ms
          if (config.jitterPercent > 0.1) {
            // With sufficient jitter, we should see some variation
            expect(uniqueDelays.size).toBeGreaterThan(1);
          }
        }
      ),
      { numRuns: 15 }
    );
  });

  /**
   * Test that retry mechanism doesn't interfere with normal operation
   */
  it('should not interfere with normal operation when no retries are needed', () => {
    const { result } = renderHook(() => useVehicleProcessing({
      filterByFavorites: false,
      maxStations: 2,
      maxVehiclesPerStation: 5
    }));

    // Normal operation should work without any retry logic interference
    expect(result.current).toBeDefined();
    expect(Array.isArray(result.current.stationVehicleGroups)).toBe(true);
    expect(Array.isArray(result.current.allStations)).toBe(true);
    expect(Array.isArray(result.current.vehicles)).toBe(true);
    
    // Loading states should be stable
    expect(typeof result.current.isLoading).toBe('boolean');
    expect(typeof result.current.isLoadingStations).toBe('boolean');
    expect(typeof result.current.isLoadingVehicles).toBe('boolean');
    expect(typeof result.current.isProcessingVehicles).toBe('boolean');
    
    // No error should be present in normal operation
    // (or if there is an error, it should be handled gracefully)
    if (result.current.error) {
      expect(result.current.error).toBeInstanceOf(Error);
    }
    
    // Constraints should be respected
    expect(result.current.stationVehicleGroups.length).toBeLessThanOrEqual(2);
    result.current.stationVehicleGroups.forEach(group => {
      expect(group.vehicles.length).toBeLessThanOrEqual(5);
    });
  });
});