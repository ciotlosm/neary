import { renderHook, waitFor, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { useVehicleData } from './useVehicleData';
import { DataHookError, DataHookErrorType } from './useStationData';
import { setupMSW, mockEndpoint, mockNetworkError, resetMocks } from '../../test/utils/mswSetup';
import { globalCache } from '../shared/cacheManager';
import type { LiveVehicle } from '../../types/tranzyApi';

// Setup MSW for API mocking
setupMSW();

// Mock logger to avoid console output during tests
vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  }
}));

// Mock the tranzy API service
vi.mock('../../services/tranzyApiService', () => ({
  tranzyApiService: vi.fn()
}));

// Mock vehicle data for testing
const mockVehicleData: LiveVehicle[] = [
  {
    id: 'vehicle-1',
    routeId: '42',
    tripId: 'trip-1',
    label: 'Bus 42',
    position: {
      latitude: 46.7712,
      longitude: 23.6236,
      bearing: 90
    },
    timestamp: new Date(),
    speed: 25,
    occupancy: 'MANY_SEATS_AVAILABLE',
    isWheelchairAccessible: true,
    isBikeAccessible: false
  },
  {
    id: 'vehicle-2',
    routeId: '43',
    tripId: 'trip-2',
    label: 'Bus 43',
    position: {
      latitude: 46.7700,
      longitude: 23.6200,
      bearing: 180
    },
    timestamp: new Date(),
    speed: 30,
    occupancy: 'FEW_SEATS_AVAILABLE',
    isWheelchairAccessible: false,
    isBikeAccessible: true
  }
];

describe('useVehicleData', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    globalCache.clear();
    resetMocks();
  });

  afterEach(() => {
    globalCache.clear();
    resetMocks();
  });

  describe('Basic functionality', () => {
    it('should fetch and return vehicle data successfully', async () => {
      // Mock successful API response
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      const { result } = renderHook(() => useVehicleData());

      // Initially loading
      expect(result.current.isLoading).toBe(true);
      expect(result.current.data).toBe(null);
      expect(result.current.error).toBe(null);

      // Wait for data to load
      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      expect(result.current.data).toBeDefined();
      expect(Array.isArray(result.current.data)).toBe(true);
      expect(result.current.error).toBe(null);
      expect(result.current.lastUpdated).toBeInstanceOf(Date);
    });

    it('should use provided agency ID', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      const { result } = renderHook(() => useVehicleData({ agencyId: '5' }));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      expect(result.current.data).toBeDefined();
    });

    it('should use provided route ID', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      const { result } = renderHook(() => useVehicleData({ routeId: '42' }));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      expect(result.current.data).toBeDefined();
    });
  });

  describe('Caching behavior', () => {
    it('should cache vehicle data and return from cache on subsequent calls', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      // First render
      const { result: result1 } = renderHook(() => useVehicleData({ cacheMaxAge: 60000 }));
      await waitFor(() => expect(result1.current.isLoading).toBe(false), { timeout: 5000 });

      // Second render should use cache (same parameters)
      const { result: result2 } = renderHook(() => useVehicleData({ cacheMaxAge: 60000 }));
      await waitFor(() => expect(result2.current.isLoading).toBe(false), { timeout: 5000 });

      expect(result2.current.data).toBeDefined();
      expect(result1.current.data).toBeDefined();
    });

    it('should bypass cache when forceRefresh is true', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      // First render
      const { result: result1 } = renderHook(() => useVehicleData());
      await waitFor(() => expect(result1.current.isLoading).toBe(false), { timeout: 5000 });

      // Second render with forceRefresh
      const { result: result2 } = renderHook(() => useVehicleData({ forceRefresh: true }));
      await waitFor(() => expect(result2.current.isLoading).toBe(false), { timeout: 5000 });

      expect(result2.current.data).toBeDefined();
    });

    it('should cleanup cache properly', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      const { result, unmount } = renderHook(() => useVehicleData());
      
      await waitFor(() => expect(result.current.isLoading).toBe(false), { timeout: 5000 });

      // Unmount should not throw errors
      expect(() => unmount()).not.toThrow();
    });
  });

  describe('Error handling scenarios', () => {
    it('should handle authentication errors (401)', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', { error: 'Unauthorized' }, 401);

      const { result } = renderHook(() => useVehicleData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      expect(result.current.error).toBeTruthy();
      if (result.current.error && result.current.error instanceof DataHookError) {
        expect(result.current.error.type).toBe(DataHookErrorType.AUTHENTICATION_ERROR);
        expect(result.current.error.retryable).toBe(false);
      }
    });

    it('should handle server errors (500)', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', { error: 'Server Error' }, 500);

      const { result } = renderHook(() => useVehicleData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 8000 });

      expect(result.current.error).toBeTruthy();
      if (result.current.error && result.current.error instanceof DataHookError) {
        expect(result.current.error.type).toBe(DataHookErrorType.NETWORK_ERROR);
        expect(result.current.error.retryable).toBe(true);
      }
    });

    it('should handle network errors', async () => {
      mockNetworkError('/api/tranzy/v1/opendata/vehicles');

      const { result } = renderHook(() => useVehicleData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 8000 });

      expect(result.current.error).toBeTruthy();
      if (result.current.error && result.current.error instanceof DataHookError) {
        expect(result.current.error.type).toBe(DataHookErrorType.NETWORK_ERROR);
        expect(result.current.error.retryable).toBe(true);
      }
    });

    it('should handle validation errors (400)', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', { error: 'Bad Request' }, 400);

      const { result } = renderHook(() => useVehicleData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      expect(result.current.error).toBeTruthy();
      if (result.current.error && result.current.error instanceof DataHookError) {
        expect(result.current.error.type).toBe(DataHookErrorType.VALIDATION_ERROR);
        expect(result.current.error.retryable).toBe(false);
      }
    });
  });

  describe('Data validation', () => {
    it('should filter out invalid vehicle data', async () => {
      const invalidVehicleData = [
        ...mockVehicleData,
        // Invalid vehicles that should be filtered out
        { id: 'invalid-1' }, // Missing required fields
        { 
          id: 'invalid-2', 
          routeId: '42',
          position: { latitude: 'invalid', longitude: 23.6236 } // Invalid coordinates
        },
        {
          id: 'invalid-3',
          routeId: '42',
          position: { latitude: 91, longitude: 23.6236 } // Out of range latitude
        }
      ];

      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', invalidVehicleData);

      const { result } = renderHook(() => useVehicleData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      // Should only return valid vehicles (filtered by validation)
      expect(result.current.data).toBeDefined();
      expect(Array.isArray(result.current.data)).toBe(true);
      // The exact count depends on validation logic, but should be less than total
      expect(result.current.data!.length).toBeLessThanOrEqual(invalidVehicleData.length);
    });

    it('should sanitize vehicle data fields', async () => {
      const unsanitizedData = [{
        id: 'vehicle-1',
        routeId: '42',
        tripId: 'trip-1',
        label: '', // Empty label should be replaced
        position: {
          latitude: 46.7712,
          longitude: 23.6236,
          bearing: 450 // Invalid bearing should be removed
        },
        timestamp: new Date().toISOString(), // String timestamp should be converted
        speed: -10, // Negative speed should be set to 0
        occupancy: 'MANY_SEATS_AVAILABLE',
        isWheelchairAccessible: 'true', // String should be converted to boolean
        isBikeAccessible: 0 // Number should be converted to boolean
      }];

      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', unsanitizedData);

      const { result } = renderHook(() => useVehicleData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      expect(result.current.data).toBeDefined();
      expect(Array.isArray(result.current.data)).toBe(true);
      if (result.current.data && result.current.data.length > 0) {
        const sanitizedVehicle = result.current.data[0];
        expect(sanitizedVehicle.timestamp).toBeInstanceOf(Date);
        expect(typeof sanitizedVehicle.isWheelchairAccessible).toBe('boolean');
        expect(typeof sanitizedVehicle.isBikeAccessible).toBe('boolean');
      }
    });

    it('should filter out stale vehicle data', async () => {
      const staleData = [{
        ...mockVehicleData[0],
        timestamp: new Date(Date.now() - 15 * 60 * 1000) // 15 minutes old
      }];

      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', staleData);

      const { result } = renderHook(() => useVehicleData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      // Stale data should be filtered out
      expect(result.current.data).toBeDefined();
      expect(Array.isArray(result.current.data)).toBe(true);
      // Stale data should be filtered, so expect empty or very few results
      expect(result.current.data!.length).toBeLessThanOrEqual(1);
    });
  });

  describe('Manual refetch', () => {
    it('should allow manual refetch of data', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      const { result } = renderHook(() => useVehicleData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      const initialLastUpdated = result.current.lastUpdated;

      // Wait a bit to ensure timestamp difference
      await new Promise(resolve => setTimeout(resolve, 50));

      // Manual refetch
      await act(async () => {
        await result.current.refetch();
      });

      // Verify refetch updated timestamp
      if (result.current.lastUpdated && initialLastUpdated) {
        expect(result.current.lastUpdated.getTime()).toBeGreaterThanOrEqual(initialLastUpdated.getTime());
      }
      expect(result.current.data).toBeDefined();
    });

    it('should handle refetch errors gracefully', async () => {
      // Initial successful load
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      const { result } = renderHook(() => useVehicleData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      // Mock error for refetch
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', { error: 'Server Error' }, 500);

      // Manual refetch should handle error
      await act(async () => {
        await result.current.refetch();
      });

      expect(result.current.error).toBeTruthy();
    });
  });

  describe('Auto-refresh functionality', () => {
    it('should setup auto-refresh when enabled', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      const { result } = renderHook(() => useVehicleData({ 
        autoRefresh: true, 
        refreshInterval: 1000 
      }));

      // Wait for initial load
      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      expect(result.current.data).toBeDefined();
    });

    it('should not setup auto-refresh when disabled', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      const { result } = renderHook(() => useVehicleData({ 
        autoRefresh: false 
      }));

      // Wait for initial load
      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      expect(result.current.data).toBeDefined();
    });
  });

  describe('Cleanup', () => {
    it('should cleanup resources on unmount', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/vehicles', mockVehicleData);

      const { result, unmount } = renderHook(() => useVehicleData({ 
        autoRefresh: true 
      }));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      // Unmount should not throw errors
      expect(() => unmount()).not.toThrow();
    });
  });
});