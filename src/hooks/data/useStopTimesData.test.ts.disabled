import { renderHook, waitFor } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { useStopTimesData } from './useStopTimesData';
import type { StopTime } from '../../types/tranzyApi';

// Mock the tranzy API service
const mockApiService = {
  getStopTimes: vi.fn()
};

vi.mock('../../services/tranzyApiService', () => ({
  tranzyApiService: () => mockApiService
}));

// Mock the config store
vi.mock('../../stores/configStore', () => ({
  useConfigStore: {
    getState: () => ({
      config: { agencyId: '2' }
    })
  }
}));

// Mock the logger
vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  }
}));

describe('useStopTimesData', () => {
  const mockStopTimes: StopTime[] = [
    {
      tripId: 'trip_1',
      stopId: '123',
      arrivalTime: '08:30:00',
      departureTime: '08:31:00',
      sequence: 1,
      headsign: 'Downtown',
      isPickupAvailable: true,
      isDropOffAvailable: true
    },
    {
      tripId: 'trip_1',
      stopId: '124',
      arrivalTime: '08:35:00',
      departureTime: '08:36:00',
      sequence: 2,
      headsign: 'Downtown',
      isPickupAvailable: true,
      isDropOffAvailable: true
    }
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    mockApiService.getStopTimes.mockResolvedValue(mockStopTimes);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('should fetch and return stop times data successfully', async () => {
    const { result } = renderHook(() => useStopTimesData());

    // Initially loading
    expect(result.current.isLoading).toBe(true);
    expect(result.current.data).toBe(null);
    expect(result.current.error).toBe(null);

    // Wait for data to load
    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(mockApiService.getStopTimes).toHaveBeenCalledWith(2, undefined, undefined, false);
    expect(result.current.data).toEqual(mockStopTimes);
    expect(result.current.error).toBe(null);
    expect(result.current.lastUpdated).toBeInstanceOf(Date);
  });

  it('should handle filtering by stop ID and trip ID', async () => {
    const { result } = renderHook(() => 
      useStopTimesData({ 
        stopId: '123', 
        tripId: 'trip_1' 
      })
    );

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(mockApiService.getStopTimes).toHaveBeenCalledWith(2, 123, 'trip_1', false);
    expect(result.current.data).toBeDefined();
    // The API service should handle filtering, so we expect some data
    expect(result.current.data!.length).toBeGreaterThan(0);
  });

  it('should validate and process stop times data correctly', async () => {
    const invalidStopTimes = [
      // Valid stop time
      {
        tripId: 'trip_1',
        stopId: '123',
        arrivalTime: '08:30:00',
        departureTime: '08:31:00',
        sequence: 1,
        isPickupAvailable: true,
        isDropOffAvailable: true
      },
      // Invalid stop time (missing required fields)
      {
        tripId: null,
        stopId: '124'
      },
      // Valid stop time with invalid time format
      {
        tripId: 'trip_2',
        stopId: '125',
        arrivalTime: 'invalid-time',
        departureTime: '08:36:00',
        sequence: 2,
        isPickupAvailable: true,
        isDropOffAvailable: true
      }
    ];

    mockApiService.getStopTimes.mockResolvedValue(invalidStopTimes);

    const { result } = renderHook(() => useStopTimesData());

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    // Should filter out invalid stop times and process valid ones
    expect(result.current.data).toBeDefined();
    expect(result.current.data!.length).toBe(2); // Only valid ones
    expect(result.current.data![0].tripId).toBe('trip_1');
    expect(result.current.data![1].tripId).toBe('trip_2');
    expect(result.current.data![1].arrivalTime).toBe('00:00:00'); // Invalid time should be defaulted
  });

  it('should handle refetch functionality', async () => {
    const { result } = renderHook(() => useStopTimesData());

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    const initialTimestamp = result.current.lastUpdated;

    // Clear the mock to track new calls
    mockApiService.getStopTimes.mockClear();

    // Trigger refetch
    await result.current.refetch();

    // Verify refetch updated timestamp
    expect(result.current.lastUpdated).not.toBe(initialTimestamp);
    expect(result.current.data).toBeDefined();
  });

  it('should handle error scenarios gracefully', async () => {
    const error = new Error('API Error');
    mockApiService.getStopTimes.mockRejectedValue(error);

    const { result } = renderHook(() => useStopTimesData());

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(result.current.error).toBeDefined();
    // Data should be null or empty array on initial error
    expect(result.current.data === null || (Array.isArray(result.current.data) && result.current.data.length === 0)).toBe(true);
  });

  it('should handle auto-refresh when enabled', async () => {
    vi.useFakeTimers();

    const { result } = renderHook(() => 
      useStopTimesData({ 
        autoRefresh: true, 
        refreshInterval: 1000 
      })
    );

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    // Clear the mock to track new calls
    mockApiService.getStopTimes.mockClear();

    // Fast-forward time to trigger auto-refresh
    vi.advanceTimersByTime(1000);

    await waitFor(() => {
      expect(mockApiService.getStopTimes).toHaveBeenCalled();
    });

    vi.useRealTimers();
  });

  it('should handle custom agency ID', async () => {
    const { result } = renderHook(() => 
      useStopTimesData({ agencyId: '5' })
    );

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(mockApiService.getStopTimes).toHaveBeenCalledWith(5, undefined, undefined, false);
  });

  it('should handle force refresh', async () => {
    const { result } = renderHook(() => 
      useStopTimesData({ forceRefresh: true })
    );

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(mockApiService.getStopTimes).toHaveBeenCalledWith(2, undefined, undefined, true);
  });

  describe('Filtering and validation', () => {
    it('should validate time format correctly', async () => {
      const stopTimesWithInvalidTimes = [
        {
          tripId: 'trip_1',
          stopId: '123',
          arrivalTime: 'invalid-time',
          departureTime: '25:70:90', // Invalid time values
          sequence: 1,
          isPickupAvailable: true,
          isDropOffAvailable: true
        },
        {
          tripId: 'trip_2',
          stopId: '124',
          arrivalTime: '08:30:00',
          departureTime: '08:31:00',
          sequence: 2,
          isPickupAvailable: true,
          isDropOffAvailable: true
        }
      ];

      mockApiService.getStopTimes.mockResolvedValue(stopTimesWithInvalidTimes);

      const { result } = renderHook(() => useStopTimesData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.data).toBeDefined();
      expect(result.current.data!.length).toBe(2);
      
      // Check that invalid times are corrected
      const firstStopTime = result.current.data!.find(st => st.tripId === 'trip_1');
      expect(firstStopTime?.arrivalTime).toBe('00:00:00'); // Should be defaulted
      expect(firstStopTime?.departureTime).toBe('00:00:00'); // Should be defaulted
      
      // Valid times should remain unchanged
      const secondStopTime = result.current.data!.find(st => st.tripId === 'trip_2');
      expect(secondStopTime?.arrivalTime).toBe('08:30:00');
      expect(secondStopTime?.departureTime).toBe('08:31:00');
    });

    it('should remove duplicate stop times', async () => {
      const duplicateStopTimes = [
        {
          tripId: 'trip_1',
          stopId: '123',
          arrivalTime: '08:30:00',
          departureTime: '08:31:00',
          sequence: 1,
          isPickupAvailable: true,
          isDropOffAvailable: true
        },
        {
          tripId: 'trip_1',
          stopId: '123',
          arrivalTime: '08:30:00',
          departureTime: '08:31:00',
          sequence: 1, // Same trip, stop, and sequence - should be deduplicated
          isPickupAvailable: true,
          isDropOffAvailable: true
        },
        {
          tripId: 'trip_1',
          stopId: '124',
          arrivalTime: '08:35:00',
          departureTime: '08:36:00',
          sequence: 2,
          isPickupAvailable: true,
          isDropOffAvailable: true
        }
      ];

      mockApiService.getStopTimes.mockResolvedValue(duplicateStopTimes);

      const { result } = renderHook(() => useStopTimesData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.data).toBeDefined();
      expect(result.current.data!.length).toBe(2); // Duplicates should be removed
    });

    it('should sort stop times by trip ID and sequence', async () => {
      const unsortedStopTimes = [
        {
          tripId: 'trip_2',
          stopId: '124',
          arrivalTime: '08:35:00',
          departureTime: '08:36:00',
          sequence: 2,
          isPickupAvailable: true,
          isDropOffAvailable: true
        },
        {
          tripId: 'trip_1',
          stopId: '123',
          arrivalTime: '08:30:00',
          departureTime: '08:31:00',
          sequence: 1,
          isPickupAvailable: true,
          isDropOffAvailable: true
        },
        {
          tripId: 'trip_1',
          stopId: '125',
          arrivalTime: '08:40:00',
          departureTime: '08:41:00',
          sequence: 3,
          isPickupAvailable: true,
          isDropOffAvailable: true
        }
      ];

      mockApiService.getStopTimes.mockResolvedValue(unsortedStopTimes);

      const { result } = renderHook(() => useStopTimesData());

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.data).toBeDefined();
      expect(result.current.data!.length).toBe(3);
      
      // Should be sorted by trip ID first, then by sequence
      expect(result.current.data![0].tripId).toBe('trip_1');
      expect(result.current.data![0].sequence).toBe(1);
      expect(result.current.data![1].tripId).toBe('trip_1');
      expect(result.current.data![1].sequence).toBe(3);
      expect(result.current.data![2].tripId).toBe('trip_2');
      expect(result.current.data![2].sequence).toBe(2);
    });
  });

  describe('Caching and cleanup', () => {
    it('should handle cache expiration correctly', async () => {
      const { result } = renderHook(() => 
        useStopTimesData({ 
          cacheMaxAge: 100 // Very short cache
        })
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.data).toBeDefined();

      // Clear the mock to track new calls
      mockApiService.getStopTimes.mockClear();

      // Wait for cache to expire
      await new Promise(resolve => setTimeout(resolve, 150));

      // Next call should fetch fresh data
      const { result: result2 } = renderHook(() => 
        useStopTimesData({ 
          cacheMaxAge: 100 
        })
      );

      await waitFor(() => {
        expect(result2.current.isLoading).toBe(false);
      });

      expect(mockApiService.getStopTimes).toHaveBeenCalled();
    });

    it('should cleanup resources on unmount', async () => {
      const { result, unmount } = renderHook(() => 
        useStopTimesData({ 
          autoRefresh: true,
          refreshInterval: 1000
        })
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      // Unmount should not throw errors
      expect(() => unmount()).not.toThrow();
    });
  });
});