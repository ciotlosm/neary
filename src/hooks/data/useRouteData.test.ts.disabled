import { renderHook, waitFor, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { useRouteData } from './useRouteData';
import { DataHookError, DataHookErrorType } from './useStationData';
import { setupMSW, mockEndpoint, mockNetworkError, resetMocks } from '../../test/utils/mswSetup';
import { globalCache } from '../shared/cacheManager';

// Setup MSW for API mocking
setupMSW();

vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  }
}));

describe('useRouteData', () => {
  const mockRoutes = [
    {
      route_id: 1,
      agency_id: 2,
      route_short_name: '1',
      route_long_name: 'Mănăștur - Zorilor',
      route_type: 3,
      route_color: 'FF0000',
      route_text_color: 'FFFFFF'
    },
    {
      route_id: 2,
      agency_id: 2,
      route_short_name: '2',
      route_long_name: 'Gheorgheni - Centru',
      route_type: 3,
      route_color: '00FF00',
      route_text_color: '000000'
    }
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    resetMocks();
  });

  afterEach(() => {
    resetMocks();
  });

  it('should fetch and return route data successfully', async () => {
    mockEndpoint('get', '/api/tranzy/v1/opendata/routes', mockRoutes);

    const { result } = renderHook(() => useRouteData());

    // Initially loading
    expect(result.current.isLoading).toBe(true);
    expect(result.current.data).toBe(null);
    expect(result.current.error).toBe(null);

    // Wait for data to load
    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    expect(result.current.data).toBeDefined();
    expect(Array.isArray(result.current.data)).toBe(true);
    expect(result.current.error).toBe(null);
    expect(result.current.lastUpdated).toBeInstanceOf(Date);
  });

  it('should return cached data when available', async () => {
    // First call to populate cache
    mockEndpoint('get', '/api/tranzy/v1/opendata/routes', mockRoutes);

    const { result } = renderHook(() => useRouteData({ cacheMaxAge: 60000 }));

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(result.current.data).toBeDefined();
    expect(Array.isArray(result.current.data)).toBe(true);
    expect(result.current.error).toBe(null);
  });

  it('should handle API errors gracefully', async () => {
    mockNetworkError('/api/tranzy/v1/opendata/routes');

    const { result } = renderHook(() => useRouteData());

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 8000 });

    // Should provide fallback data for offline scenarios
    expect(result.current.data).toBeDefined();
    expect(Array.isArray(result.current.data)).toBe(true);
    expect(result.current.data!.length).toBeGreaterThan(0);
  });

  it('should validate and process route data correctly', async () => {
    // Test basic validation by checking that the hook processes data correctly
    // Use a different agency ID to avoid cache conflicts
    const validRoutes = [
      {
        route_id: 10,
        agency_id: 3,
        route_short_name: 'A1',
        route_long_name: 'Test Route A1',
        route_type: 3,
        route_color: '#FF0000', // Valid color
        route_text_color: '#FFFFFF'
      },
      {
        route_id: 11,
        agency_id: 3,
        route_short_name: 'B2',
        route_long_name: 'Test Route B2',
        route_type: 3,
        route_color: 'invalid-color', // Invalid color format
        route_text_color: '#000000'
      }
    ];

    mockEndpoint('get', '/api/tranzy/v1/opendata/routes', validRoutes);

    const { result } = renderHook(() => useRouteData({ 
      agencyId: '3', // Different agency to avoid cache conflicts
      cacheMaxAge: 10 
    }));

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    // Should process all valid routes
    expect(result.current.data).toBeDefined();
    expect(result.current.data!.length).toBe(2);
    
    // Check that routes are properly processed
    const routeA1 = result.current.data!.find(r => r.routeName === 'A1');
    const routeB2 = result.current.data!.find(r => r.routeName === 'B2');
    
    expect(routeA1).toBeDefined();
    expect(routeA1?.color).toBe('#FF0000'); // Valid color should remain
    
    expect(routeB2).toBeDefined();
    expect(routeB2?.color).toBeUndefined(); // Invalid color should be filtered out
    expect(routeB2?.textColor).toBe('#000000'); // Valid text color should remain
  });

  it('should provide fallback data for network errors', async () => {
    // Mock a network error to trigger fallback
    mockNetworkError('/api/tranzy/v1/opendata/routes');

    const { result } = renderHook(() => useRouteData({ 
      agencyId: '2', 
      cacheMaxAge: 10 // Short cache to avoid conflicts
    }));

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 8000 });

    // Should provide fallback data for offline scenarios
    expect(result.current.data).toBeDefined();
    expect(Array.isArray(result.current.data)).toBe(true);
    expect(result.current.data!.length).toBeGreaterThan(0); // Should have some fallback routes
    
    // Check that fallback routes have required properties
    const firstRoute = result.current.data![0];
    expect(firstRoute.id).toBeDefined();
    expect(firstRoute.routeName).toBeDefined();
    expect(firstRoute.routeDesc).toBeDefined();
    expect(firstRoute.type).toBe('bus');
  });

  it('should refetch data when refetch is called', async () => {
    mockEndpoint('get', '/api/tranzy/v1/opendata/routes', mockRoutes);

    const { result } = renderHook(() => useRouteData());

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    const initialLastUpdated = result.current.lastUpdated;

    // Wait a bit to ensure timestamp difference
    await new Promise(resolve => setTimeout(resolve, 50));

    // Call refetch and wait for it to complete
    await waitFor(async () => {
      await result.current.refetch();
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    // Verify refetch updated timestamp
    if (result.current.lastUpdated && initialLastUpdated) {
      expect(result.current.lastUpdated.getTime()).toBeGreaterThanOrEqual(initialLastUpdated.getTime());
    }
    expect(result.current.data).toBeDefined();
  });

  describe('Caching behavior and cleanup', () => {
    beforeEach(() => {
      globalCache.clear();
    });

    afterEach(() => {
      globalCache.clear();
    });

    it('should cache route data and return from cache on subsequent calls', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/routes', mockRoutes);

      // First render
      const { result: result1 } = renderHook(() => useRouteData({ 
        agencyId: '1', 
        cacheMaxAge: 60000 
      }));
      
      await waitFor(() => expect(result1.current.isLoading).toBe(false), { timeout: 5000 });

      // Second render should use cache (same parameters)
      const { result: result2 } = renderHook(() => useRouteData({ 
        agencyId: '1', 
        cacheMaxAge: 60000 
      }));
      
      await waitFor(() => expect(result2.current.isLoading).toBe(false), { timeout: 5000 });

      expect(result2.current.data).toBeDefined();
      expect(result1.current.data).toBeDefined();
    });

    it('should bypass cache when forceRefresh is true', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/routes', mockRoutes);

      // First render
      const { result: result1 } = renderHook(() => useRouteData({ agencyId: '1' }));
      await waitFor(() => expect(result1.current.isLoading).toBe(false), { timeout: 5000 });

      // Second render with forceRefresh
      const { result: result2 } = renderHook(() => useRouteData({ 
        agencyId: '1', 
        forceRefresh: true 
      }));
      await waitFor(() => expect(result2.current.isLoading).toBe(false), { timeout: 5000 });

      expect(result2.current.data).toBeDefined();
    });

    it('should cleanup cache properly on unmount', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/routes', mockRoutes);

      const { result, unmount } = renderHook(() => useRouteData({ agencyId: '1' }));
      
      await waitFor(() => expect(result.current.isLoading).toBe(false), { timeout: 5000 });

      // Unmount should not throw errors
      expect(() => unmount()).not.toThrow();
    });

    it('should handle different cache configurations', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/routes', mockRoutes);

      // Test with very short cache
      const { result } = renderHook(() => useRouteData({ 
        agencyId: '1', 
        cacheMaxAge: 100 // 100ms cache
      }));
      
      await waitFor(() => expect(result.current.isLoading).toBe(false), { timeout: 5000 });
      expect(result.current.data).toBeDefined();

      // Wait for cache to expire
      await new Promise(resolve => setTimeout(resolve, 150));

      // Next call should fetch fresh data
      const { result: result2 } = renderHook(() => useRouteData({ 
        agencyId: '1', 
        cacheMaxAge: 100 
      }));
      
      await waitFor(() => expect(result2.current.isLoading).toBe(false), { timeout: 5000 });
      expect(result2.current.data).toBeDefined();
    });
  });

  describe('Error handling and fallbacks', () => {
    it('should handle authentication errors (401)', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/routes', { error: 'Unauthorized' }, 401);

      const { result } = renderHook(() => useRouteData({ agencyId: '1' }));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      expect(result.current.error).toBeTruthy();
      if (result.current.error && result.current.error instanceof DataHookError) {
        expect(result.current.error.type).toBe(DataHookErrorType.AUTHENTICATION_ERROR);
        expect(result.current.error.retryable).toBe(false);
      }
    });

    it('should handle server errors with retry', async () => {
      mockEndpoint('get', '/api/tranzy/v1/opendata/routes', { error: 'Server Error' }, 500);

      const { result } = renderHook(() => useRouteData({ agencyId: '1' }));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 8000 });

      // Should either have error or fallback data
      expect(result.current.error || result.current.data).toBeTruthy();
    });

    it('should handle refetch errors gracefully', async () => {
      // Initial successful load
      mockEndpoint('get', '/api/tranzy/v1/opendata/routes', mockRoutes);

      const { result } = renderHook(() => useRouteData({ agencyId: '1' }));

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      }, { timeout: 5000 });

      // Mock error for refetch
      mockEndpoint('get', '/api/tranzy/v1/opendata/routes', { error: 'Server Error' }, 500);

      // Manual refetch should handle error
      await act(async () => {
        await result.current.refetch();
      });

      // Should have error or maintain previous data
      expect(result.current.error || result.current.data).toBeTruthy();
    });
  });
});