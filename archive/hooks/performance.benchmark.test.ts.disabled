import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

/**
 * Performance Benchmark: Old vs New Hook Implementation
 * 
 * This test compares the performance of the original 829-line useVehicleProcessing hook
 * against the new orchestrated hook implementation with performance optimizations.
 */

// Mock the stores and dependencies for both implementations
vi.mock('../stores/locationStore', () => ({
  useLocationStore: vi.fn(() => ({
    currentLocation: { latitude: 46.7712, longitude: 23.6236 }
  }))
}));

vi.mock('../stores/configStore', () => ({
  useConfigStore: vi.fn(() => ({
    config: {
      agencyId: '2',
      homeLocation: { latitude: 46.7712, longitude: 23.6236 },
      workLocation: { latitude: 46.7800, longitude: 23.6300 },
      defaultLocation: { latitude: 46.7712, longitude: 23.6236 },
      favoriteBuses: [
        { routeName: 'Route 1', direction: 'work' },
        { routeName: 'Route 2', direction: 'home' }
      ]
    }
  }))
}));

// Mock the enhanced bus store for old implementation
vi.mock('../stores/enhancedBusStore', () => ({
  useEnhancedBusStore: vi.fn(() => ({
    // Mock store methods
  }))
}));

// Mock API config
vi.mock('./useApiConfig', () => ({
  useApiConfig: vi.fn(() => ({
    setupApi: vi.fn(() => 2),
    isConfigured: true
  }))
}));

// Mock async operation
vi.mock('./useAsyncOperation', () => ({
  useAsyncOperation: vi.fn(() => ({
    execute: vi.fn((fn) => fn()),
    isLoading: false,
    error: null
  }))
}));

// Mock the API service
vi.mock('../services/tranzyApiService', () => ({
  enhancedTranzyApi: {
    getStops: vi.fn(() => Promise.resolve(mockStations)),
    getVehicles: vi.fn(() => Promise.resolve(mockVehicles)),
    getRoutes: vi.fn(() => Promise.resolve(mockRoutes)),
    getStopTimes: vi.fn(() => Promise.resolve(mockStopTimes)),
    getTrips: vi.fn(() => Promise.resolve(mockTrips))
  }
}));

// Mock data hooks for new implementation
vi.mock('./data/useStationData', () => ({
  useStationData: vi.fn(() => ({
    data: mockStations,
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('./data/useVehicleData', () => ({
  useVehicleData: vi.fn(() => ({
    data: mockVehicles,
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('./data/useRouteData', () => ({
  useRouteData: vi.fn(() => ({
    data: mockRoutes,
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('./data/useStopTimesData', () => ({
  useStopTimesData: vi.fn(() => ({
    data: mockStopTimes,
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

// Mock processing hooks for new implementation
vi.mock('./processing/useVehicleFiltering', () => ({
  useVehicleFiltering: vi.fn(() => ({
    filteredVehicles: mockVehicles,
    filterStats: {
      totalVehicles: mockVehicles.length,
      filteredCount: mockVehicles.length,
      appliedFilters: []
    }
  }))
}));

vi.mock('./processing/useVehicleGrouping', () => ({
  useVehicleGrouping: vi.fn(() => ({
    stationGroups: [
      {
        station: { station: mockStations[0], distance: 100 },
        vehicles: [mockVehicles[0]],
        allRoutes: [{ routeId: 'route1', routeName: 'Route 1', vehicleCount: 1 }]
      }
    ],
    groupingStats: {
      totalStations: 1,
      totalVehicles: 1,
      averageVehiclesPerStation: 1
    }
  }))
}));

// Mock utilities
vi.mock('../utils/locationUtils', () => ({
  getEffectiveLocation: vi.fn((current, home, work, defaultLoc) => current || home || defaultLoc)
}));

vi.mock('../utils/distanceUtils', () => ({
  calculateDistance: vi.fn(() => 100)
}));

// Test data
const mockStations = Array.from({ length: 50 }, (_, i) => ({
  id: `station${i}`,
  name: `Station ${i}`,
  coordinates: { latitude: 46.7712 + (i * 0.001), longitude: 23.6236 + (i * 0.001) }
}));

const mockVehicles = Array.from({ length: 100 }, (_, i) => ({
  id: `vehicle${i}`,
  routeId: `route${i % 10}`,
  tripId: `trip${i}`,
  label: `Bus ${i}`,
  position: { latitude: 46.7712 + (i * 0.0005), longitude: 23.6236 + (i * 0.0005) },
  timestamp: new Date(),
  speed: 20 + (i % 30),
  isWheelchairAccessible: i % 2 === 0,
  isBikeAccessible: i % 3 === 0
}));

const mockRoutes = Array.from({ length: 10 }, (_, i) => ({
  id: `route${i}`,
  routeName: `Route ${i}`,
  routeDesc: `Route ${i} Description`,
  routeType: 3,
  agencyId: '2'
}));

const mockStopTimes = Array.from({ length: 200 }, (_, i) => ({
  tripId: `trip${i % 100}`,
  stopId: `station${i % 50}`,
  sequence: (i % 10) + 1,
  arrivalTime: `${8 + Math.floor(i / 10)}:${(i % 6) * 10}:00`,
  departureTime: `${8 + Math.floor(i / 10)}:${(i % 6) * 10 + 1}:00`
}));

const mockTrips = Array.from({ length: 100 }, (_, i) => ({
  id: `trip${i}`,
  routeId: `route${i % 10}`,
  headsign: `Destination ${i % 10}`,
  directionId: i % 2
}));

describe('Performance Benchmark: Old vs New Hook Implementation', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  describe('Hook Module Loading Performance', () => {
    it('should benchmark module import performance', async () => {
      // Benchmark old implementation import
      const oldImportStartTime = performance.now();
      const oldModule = await import('./useVehicleProcessing');
      const oldImportEndTime = performance.now();
      const oldImportTime = oldImportEndTime - oldImportStartTime;

      // Benchmark new implementation import
      const newImportStartTime = performance.now();
      const newModule = await import('./useVehicleProcessingOrchestration');
      const newImportEndTime = performance.now();
      const newImportTime = newImportEndTime - newImportStartTime;

      // Performance comparison
      const importImprovement = ((oldImportTime - newImportTime) / oldImportTime) * 100;
      
      console.log(`Module Import Performance Benchmark:`);
      console.log(`Old Hook Import Time: ${oldImportTime.toFixed(2)}ms`);
      console.log(`New Hook Import Time: ${newImportTime.toFixed(2)}ms`);
      console.log(`Import Performance Improvement: ${importImprovement.toFixed(2)}%`);

      // Verify both modules export the expected hook
      expect(typeof oldModule.useVehicleProcessing).toBe('function');
      expect(typeof newModule.useVehicleProcessing).toBe('function');

      // New implementation should import efficiently
      expect(newImportTime).toBeLessThan(100); // Should import within 100ms
    });

    it('should benchmark dependency tracking performance', async () => {
      const { createDependencyTracker } = await import('./shared/dependencyTracker');
      
      // Benchmark dependency tracking overhead
      const iterations = 1000;
      const tracker = createDependencyTracker();
      
      const trackingStartTime = performance.now();
      
      for (let i = 0; i < iterations; i++) {
        // Simulate typical dependency patterns
        const deps = [`dep${i % 10}`, `value${i % 5}`, i % 100];
        const hasChanged = tracker.hasChanged(`key${i % 20}`, deps);
        
        if (hasChanged) {
          tracker.updateDependencies(`key${i % 20}`, deps);
        }
      }
      
      const trackingEndTime = performance.now();
      const trackingTime = trackingEndTime - trackingStartTime;
      
      const stats = tracker.getStats();
      
      console.log(`Dependency Tracking Performance Benchmark:`);
      console.log(`${iterations} operations completed in: ${trackingTime.toFixed(2)}ms`);
      console.log(`Average time per operation: ${(trackingTime / iterations).toFixed(4)}ms`);
      console.log(`Cache hit rate: ${((stats.totalChecks - stats.totalChanges) / stats.totalChecks * 100).toFixed(2)}%`);
      
      // Should be very fast
      expect(trackingTime).toBeLessThan(100); // 1000 operations in under 100ms
      expect(trackingTime / iterations).toBeLessThan(0.1); // Under 0.1ms per operation
    });
  });

  describe('Cache Performance Comparison', () => {
    it('should benchmark cache operations performance', async () => {
      const { CacheManager } = await import('./shared/cacheManager');
      
      const iterations = 1000;
      const cache = new CacheManager({ maxSize: 100, maxAge: 5000 });
      
      // Benchmark cache operations
      const cacheStartTime = performance.now();
      
      for (let i = 0; i < iterations; i++) {
        const key = `key${i % 50}`; // Create some overlap for cache hits
        const value = `value${i}`;
        
        // Set operation
        cache.set(key, value);
        
        // Get operation
        const retrieved = cache.get(key);
        expect(retrieved).toBe(value);
        
        // Periodic cleanup
        if (i % 100 === 0) {
          cache.cleanup();
        }
      }
      
      const cacheEndTime = performance.now();
      const cacheTime = cacheEndTime - cacheStartTime;
      
      const stats = cache.getStats();
      
      console.log(`Cache Performance Benchmark:`);
      console.log(`${iterations} cache operations completed in: ${cacheTime.toFixed(2)}ms`);
      console.log(`Average time per operation: ${(cacheTime / iterations).toFixed(4)}ms`);
      console.log(`Cache size: ${stats.totalEntries}`);
      console.log(`Valid entries: ${stats.validEntries}`);
      
      // Cache operations should be very fast
      expect(cacheTime).toBeLessThan(50); // 1000 operations in under 50ms
      expect(cacheTime / iterations).toBeLessThan(0.05); // Under 0.05ms per operation
      
      cache.destroy();
    });
  });

  describe('API Compatibility Verification', () => {
    it('should verify exact API compatibility between implementations', async () => {
      const testOptions = {
        filterByFavorites: true,
        maxStations: 3,
        maxVehiclesPerStation: 10,
        showAllVehiclesPerRoute: true,
        maxSearchRadius: 2000,
        maxStationsToCheck: 15,
        proximityThreshold: 150
      };

      // Get results from both implementations
      const { useVehicleProcessing: oldHook } = await import('./useVehicleProcessing');
      const { useVehicleProcessing: newHook } = await import('./useVehicleProcessingOrchestration');

      const { result: oldResult, unmount: unmountOld } = renderHook(() => oldHook(testOptions));
      const { result: newResult, unmount: unmountNew } = renderHook(() => newHook(testOptions));

      await waitFor(() => {
        expect(oldResult.current.isLoading).toBe(false);
        expect(newResult.current.isLoading).toBe(false);
      });

      // Verify all properties exist in both results
      const expectedProperties = [
        'stationVehicleGroups',
        'isLoading',
        'isLoadingStations',
        'isLoadingVehicles',
        'isProcessingVehicles',
        'effectiveLocationForDisplay',
        'favoriteRoutes',
        'allStations',
        'vehicles'
      ];

      expectedProperties.forEach(prop => {
        expect(oldResult.current).toHaveProperty(prop);
        expect(newResult.current).toHaveProperty(prop);
        
        // Verify types match
        expect(typeof oldResult.current[prop]).toBe(typeof newResult.current[prop]);
      });

      // Verify array properties are arrays
      expect(Array.isArray(oldResult.current.stationVehicleGroups)).toBe(true);
      expect(Array.isArray(newResult.current.stationVehicleGroups)).toBe(true);
      expect(Array.isArray(oldResult.current.favoriteRoutes)).toBe(true);
      expect(Array.isArray(newResult.current.favoriteRoutes)).toBe(true);
      expect(Array.isArray(oldResult.current.allStations)).toBe(true);
      expect(Array.isArray(newResult.current.allStations)).toBe(true);
      expect(Array.isArray(oldResult.current.vehicles)).toBe(true);
      expect(Array.isArray(newResult.current.vehicles)).toBe(true);

      // Verify boolean properties are booleans
      expect(typeof oldResult.current.isLoading).toBe('boolean');
      expect(typeof newResult.current.isLoading).toBe('boolean');
      expect(typeof oldResult.current.isLoadingStations).toBe('boolean');
      expect(typeof newResult.current.isLoadingStations).toBe('boolean');
      expect(typeof oldResult.current.isLoadingVehicles).toBe('boolean');
      expect(typeof newResult.current.isLoadingVehicles).toBe('boolean');

      console.log('API Compatibility Verification: PASSED');
      console.log(`Old Hook Properties: ${Object.keys(oldResult.current).length}`);
      console.log(`New Hook Properties: ${Object.keys(newResult.current).length}`);

      unmountOld();
      unmountNew();
    });
  });

  describe('Selective Re-execution Performance', () => {
    it('should demonstrate selective re-execution benefits', async () => {
      const { useVehicleProcessing: newHook } = await import('./useVehicleProcessingOrchestration');
      
      // Test with dependency tracker
      const { createDependencyTracker } = await import('./shared/dependencyTracker');
      const tracker = createDependencyTracker();
      
      // Simulate multiple calls with same dependencies
      const startTime = performance.now();
      
      for (let i = 0; i < 100; i++) {
        const hasChanged = tracker.hasChanged('test-key', ['dep1', 'dep2', 'dep3']);
        if (hasChanged) {
          // Simulate expensive computation
          const result = Array.from({ length: 1000 }, (_, j) => j * 2);
          tracker.updateDependencies('test-key', ['dep1', 'dep2', 'dep3']);
        }
      }
      
      const endTime = performance.now();
      const executionTime = endTime - startTime;
      
      const stats = tracker.getStats();
      
      console.log('Selective Re-execution Performance:');
      console.log(`Total execution time: ${executionTime.toFixed(2)}ms`);
      console.log(`Total checks: ${stats.totalChecks}`);
      console.log(`Total changes: ${stats.totalChanges}`);
      console.log(`Cache hit rate: ${((stats.totalChecks - stats.totalChanges) / stats.totalChecks * 100).toFixed(2)}%`);
      
      // Should have high cache hit rate (99% since only first call should trigger change)
      expect(stats.changeRate).toBeLessThan(0.02); // Less than 2% change rate
      expect(executionTime).toBeLessThan(50); // Should be very fast due to caching
    });
  });
});