/**
 * Data format compatibility tests for hook migration
 * 
 * These tests verify that the new hook system returns data in exactly
 * the same format as the old implementation.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import * as fc from 'fast-check';

// Import both implementations
import { useVehicleProcessing as useVehicleProcessingOld } from '../useVehicleProcessing';
import { 
  useVehicleProcessing as useVehicleProcessingNew,
  type VehicleProcessingOptions,
  type VehicleProcessingResult
} from '../useVehicleProcessingOrchestration';

// Import test utilities
import { compatibilityVerifier } from './compatibilityVerification';

// Mock all dependencies with realistic data
const mockStations = [
  {
    id: 'station1',
    name: 'Piața Unirii',
    coordinates: { latitude: 46.7712, longitude: 23.6236 }
  },
  {
    id: 'station2',
    name: 'Mănăștur',
    coordinates: { latitude: 46.7800, longitude: 23.6300 }
  },
  {
    id: 'station3',
    name: 'Zorilor',
    coordinates: { latitude: 46.7650, longitude: 23.5800 }
  }
];

const mockVehicles = [
  {
    id: 'vehicle1',
    routeId: '1',
    tripId: 'trip1',
    label: '101',
    position: { latitude: 46.7712, longitude: 23.6236 },
    timestamp: new Date('2024-01-01T10:00:00Z'),
    speed: 25,
    isWheelchairAccessible: true,
    isBikeAccessible: false
  },
  {
    id: 'vehicle2',
    routeId: '2',
    tripId: 'trip2',
    label: '102',
    position: { latitude: 46.7800, longitude: 23.6300 },
    timestamp: new Date('2024-01-01T10:01:00Z'),
    speed: 30,
    isWheelchairAccessible: false,
    isBikeAccessible: true
  },
  {
    id: 'vehicle3',
    routeId: '1',
    tripId: 'trip3',
    label: '103',
    position: { latitude: 46.7650, longitude: 23.5800 },
    timestamp: new Date('2024-01-01T10:02:00Z'),
    speed: 20,
    isWheelchairAccessible: true,
    isBikeAccessible: true
  }
];

const mockRoutes = [
  {
    id: '1',
    routeName: 'Route 1',
    routeDesc: 'Piața Unirii - Mănăștur',
    type: 'bus' as const
  },
  {
    id: '2',
    routeName: 'Route 2',
    routeDesc: 'Centru - Zorilor',
    type: 'trolleybus' as const
  }
];

const mockStopTimes = [
  {
    tripId: 'trip1',
    stopId: 'station1',
    sequence: 1,
    arrivalTime: '10:00:00',
    departureTime: '10:01:00'
  },
  {
    tripId: 'trip1',
    stopId: 'station2',
    sequence: 2,
    arrivalTime: '10:15:00',
    departureTime: '10:16:00'
  },
  {
    tripId: 'trip2',
    stopId: 'station2',
    sequence: 1,
    arrivalTime: '10:05:00',
    departureTime: '10:06:00'
  },
  {
    tripId: 'trip2',
    stopId: 'station3',
    sequence: 2,
    arrivalTime: '10:20:00',
    departureTime: '10:21:00'
  },
  {
    tripId: 'trip3',
    stopId: 'station3',
    sequence: 1,
    arrivalTime: '10:10:00',
    departureTime: '10:11:00'
  }
];

// Setup mocks
vi.mock('../../stores/locationStore', () => ({
  useLocationStore: vi.fn(() => ({
    currentLocation: { latitude: 46.7712, longitude: 23.6236 }
  }))
}));

vi.mock('../../stores/configStore', () => ({
  useConfigStore: vi.fn(() => ({
    config: {
      agencyId: 'test-agency',
      homeLocation: { latitude: 46.7712, longitude: 23.6236 },
      workLocation: { latitude: 46.7800, longitude: 23.6300 },
      favoriteBuses: [
        { routeId: '1', routeName: 'Route 1' },
        { routeId: '2', routeName: 'Route 2' }
      ]
    }
  }))
}));

vi.mock('../data/useStationData', () => ({
  useStationData: vi.fn(() => ({
    data: mockStations,
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('../data/useVehicleData', () => ({
  useVehicleData: vi.fn(() => ({
    data: mockVehicles,
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('../data/useRouteData', () => ({
  useRouteData: vi.fn(() => ({
    data: mockRoutes,
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('../data/useStopTimesData', () => ({
  useStopTimesData: vi.fn(() => ({
    data: mockStopTimes,
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('../processing/useVehicleFiltering', () => ({
  useVehicleFiltering: vi.fn((vehicles, options) => ({
    filteredVehicles: options.filterByFavorites 
      ? vehicles.filter((v: any) => options.favoriteRoutes?.some((fav: any) => fav.routeId === v.routeId))
      : vehicles,
    filterStats: {
      totalVehicles: vehicles.length,
      filteredCount: vehicles.length,
      appliedFilters: options.filterByFavorites ? ['favorites'] : []
    }
  }))
}));

vi.mock('../processing/useVehicleGrouping', () => ({
  useVehicleGrouping: vi.fn((vehicles, stations, userLocation, options) => {
    const maxStations = options.maxStations || 2;
    const maxVehiclesPerStation = options.maxVehiclesPerStation || 5;
    
    return {
      stationGroups: stations.slice(0, maxStations).map((station: any, stationIndex: number) => {
        const stationVehicles = vehicles
          .slice(stationIndex * 2, (stationIndex + 1) * 2) // Distribute vehicles across stations
          .slice(0, maxVehiclesPerStation);
        
        return {
          station: { 
            station, 
            distance: 100 + stationIndex * 50 
          },
          vehicles: stationVehicles,
          allRoutes: stationVehicles.map((v: any) => ({
            routeId: v.routeId,
            routeName: `Route ${v.routeId}`,
            vehicleCount: 1
          }))
        };
      }),
      groupingStats: {
        totalStations: stations.length,
        groupedStations: Math.min(stations.length, maxStations),
        totalVehicles: vehicles.length
      }
    };
  })
}));

describe('Data Format Compatibility Tests', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    compatibilityVerifier.clearResults();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('Return Value Structure', () => {
    it('should return objects with identical keys', async () => {
      const options: VehicleProcessingOptions = {};

      const { result: oldResult } = renderHook(() => useVehicleProcessingOld(options));
      const { result: newResult } = renderHook(() => useVehicleProcessingNew(options));

      await waitFor(() => {
        expect(oldResult.current).toBeDefined();
        expect(newResult.current).toBeDefined();
      });

      const oldKeys = Object.keys(oldResult.current).sort();
      const newKeys = Object.keys(newResult.current).sort();

      expect(newKeys).toEqual(oldKeys);
    });

    it('should have identical property types', async () => {
      const options: VehicleProcessingOptions = {};

      const { result: oldResult } = renderHook(() => useVehicleProcessingOld(options));
      const { result: newResult } = renderHook(() => useVehicleProcessingNew(options));

      await waitFor(() => {
        expect(oldResult.current).toBeDefined();
        expect(newResult.current).toBeDefined();
      });

      const oldResult_ = oldResult.current;
      const newResult_ = newResult.current;

      // Check types of all properties
      expect(typeof oldResult_.isLoading).toBe(typeof newResult_.isLoading);
      expect(typeof oldResult_.isLoadingStations).toBe(typeof newResult_.isLoadingStations);
      expect(typeof oldResult_.isLoadingVehicles).toBe(typeof newResult_.isLoadingVehicles);
      expect(typeof oldResult_.isProcessingVehicles).toBe(typeof newResult_.isProcessingVehicles);
      
      expect(Array.isArray(oldResult_.stationVehicleGroups)).toBe(Array.isArray(newResult_.stationVehicleGroups));
      expect(Array.isArray(oldResult_.favoriteRoutes)).toBe(Array.isArray(newResult_.favoriteRoutes));
      expect(Array.isArray(oldResult_.allStations)).toBe(Array.isArray(newResult_.allStations));
      expect(Array.isArray(oldResult_.vehicles)).toBe(Array.isArray(newResult_.vehicles));

      if (oldResult_.effectiveLocationForDisplay && newResult_.effectiveLocationForDisplay) {
        expect(typeof oldResult_.effectiveLocationForDisplay.latitude).toBe('number');
        expect(typeof newResult_.effectiveLocationForDisplay.latitude).toBe('number');
        expect(typeof oldResult_.effectiveLocationForDisplay.longitude).toBe('number');
        expect(typeof newResult_.effectiveLocationForDisplay.longitude).toBe('number');
      }
    });
  });

  describe('StationVehicleGroups Structure', () => {
    it('should have identical station vehicle group structure', async () => {
      const options: VehicleProcessingOptions = {
        maxStations: 2,
        maxVehiclesPerStation: 3
      };

      const { result: oldResult } = renderHook(() => useVehicleProcessingOld(options));
      const { result: newResult } = renderHook(() => useVehicleProcessingNew(options));

      await waitFor(() => {
        expect(oldResult.current.stationVehicleGroups).toBeDefined();
        expect(newResult.current.stationVehicleGroups).toBeDefined();
      });

      const oldGroups = oldResult.current.stationVehicleGroups;
      const newGroups = newResult.current.stationVehicleGroups;

      // Both should be arrays
      expect(Array.isArray(oldGroups)).toBe(true);
      expect(Array.isArray(newGroups)).toBe(true);

      // If both have groups, check structure
      if (oldGroups.length > 0 && newGroups.length > 0) {
        const oldGroup = oldGroups[0];
        const newGroup = newGroups[0];

        // Check station structure
        expect(oldGroup.station).toBeDefined();
        expect(newGroup.station).toBeDefined();
        expect(typeof oldGroup.station.distance).toBe('number');
        expect(typeof newGroup.station.distance).toBe('number');
        expect(oldGroup.station.station).toBeDefined();
        expect(newGroup.station.station).toBeDefined();

        // Check vehicles structure
        expect(Array.isArray(oldGroup.vehicles)).toBe(true);
        expect(Array.isArray(newGroup.vehicles)).toBe(true);

        // Check allRoutes structure
        expect(Array.isArray(oldGroup.allRoutes)).toBe(true);
        expect(Array.isArray(newGroup.allRoutes)).toBe(true);

        if (oldGroup.vehicles.length > 0 && newGroup.vehicles.length > 0) {
          const oldVehicle = oldGroup.vehicles[0];
          const newVehicle = newGroup.vehicles[0];

          // Check required vehicle properties
          const requiredProps = ['id', 'routeId', 'route', 'destination'];
          requiredProps.forEach(prop => {
            expect(oldVehicle).toHaveProperty(prop);
            expect(newVehicle).toHaveProperty(prop);
          });

          // Check property types
          expect(typeof oldVehicle.id).toBe('string');
          expect(typeof newVehicle.id).toBe('string');
          expect(typeof oldVehicle.routeId).toBe('string');
          expect(typeof newVehicle.routeId).toBe('string');
          expect(typeof oldVehicle.minutesAway).toBe('number');
          expect(typeof newVehicle.minutesAway).toBe('number');
        }
      }
    });

    it('should respect maxStations limit identically', async () => {
      const testCases = [1, 2, 3, 5];

      for (const maxStations of testCases) {
        const options: VehicleProcessingOptions = { maxStations };

        const { result: oldResult } = renderHook(() => useVehicleProcessingOld(options));
        const { result: newResult } = renderHook(() => useVehicleProcessingNew(options));

        await waitFor(() => {
          expect(oldResult.current.stationVehicleGroups).toBeDefined();
          expect(newResult.current.stationVehicleGroups).toBeDefined();
        });

        const oldGroups = oldResult.current.stationVehicleGroups;
        const newGroups = newResult.current.stationVehicleGroups;

        // Both should respect the limit
        expect(oldGroups.length).toBeLessThanOrEqual(maxStations);
        expect(newGroups.length).toBeLessThanOrEqual(maxStations);

        // Ideally, they should return the same number of groups
        // (allowing for minor differences due to implementation details)
        const difference = Math.abs(oldGroups.length - newGroups.length);
        expect(difference).toBeLessThanOrEqual(1);
      }
    });

    it('should respect maxVehiclesPerStation limit identically', async () => {
      const testCases = [1, 3, 5, 10];

      for (const maxVehiclesPerStation of testCases) {
        const options: VehicleProcessingOptions = { 
          maxStations: 2,
          maxVehiclesPerStation 
        };

        const { result: oldResult } = renderHook(() => useVehicleProcessingOld(options));
        const { result: newResult } = renderHook(() => useVehicleProcessingNew(options));

        await waitFor(() => {
          expect(oldResult.current.stationVehicleGroups).toBeDefined();
          expect(newResult.current.stationVehicleGroups).toBeDefined();
        });

        const oldGroups = oldResult.current.stationVehicleGroups;
        const newGroups = newResult.current.stationVehicleGroups;

        // Check each group respects the vehicle limit
        oldGroups.forEach(group => {
          expect(group.vehicles.length).toBeLessThanOrEqual(maxVehiclesPerStation);
        });

        newGroups.forEach(group => {
          expect(group.vehicles.length).toBeLessThanOrEqual(maxVehiclesPerStation);
        });
      }
    });
  });

  describe('Vehicle Data Structure', () => {
    it('should have identical vehicle properties', async () => {
      const options: VehicleProcessingOptions = {
        maxStations: 1,
        maxVehiclesPerStation: 1
      };

      const { result: oldResult } = renderHook(() => useVehicleProcessingOld(options));
      const { result: newResult } = renderHook(() => useVehicleProcessingNew(options));

      await waitFor(() => {
        expect(oldResult.current.stationVehicleGroups).toBeDefined();
        expect(newResult.current.stationVehicleGroups).toBeDefined();
      });

      const oldGroups = oldResult.current.stationVehicleGroups;
      const newGroups = newResult.current.stationVehicleGroups;

      if (oldGroups.length > 0 && newGroups.length > 0 &&
          oldGroups[0].vehicles.length > 0 && newGroups[0].vehicles.length > 0) {
        
        const oldVehicle = oldGroups[0].vehicles[0];
        const newVehicle = newGroups[0].vehicles[0];

        // Check that both have the same properties
        const oldProps = Object.keys(oldVehicle).sort();
        const newProps = Object.keys(newVehicle).sort();

        // Allow for some differences in internal properties
        const coreProps = oldProps.filter(prop => !prop.startsWith('_'));
        const newCoreProps = newProps.filter(prop => !prop.startsWith('_'));

        expect(newCoreProps).toEqual(expect.arrayContaining(coreProps));

        // Check specific required properties
        const requiredProps = [
          'id', 'routeId', 'route', 'destination', 'minutesAway', 
          'estimatedArrival', 'station', 'isLive', 'confidence'
        ];

        requiredProps.forEach(prop => {
          expect(oldVehicle).toHaveProperty(prop);
          expect(newVehicle).toHaveProperty(prop);
          expect(typeof oldVehicle[prop]).toBe(typeof newVehicle[prop]);
        });
      }
    });

    it('should have consistent date formats', async () => {
      const options: VehicleProcessingOptions = {};

      const { result: oldResult } = renderHook(() => useVehicleProcessingOld(options));
      const { result: newResult } = renderHook(() => useVehicleProcessingNew(options));

      await waitFor(() => {
        expect(oldResult.current.stationVehicleGroups).toBeDefined();
        expect(newResult.current.stationVehicleGroups).toBeDefined();
      });

      const oldGroups = oldResult.current.stationVehicleGroups;
      const newGroups = newResult.current.stationVehicleGroups;

      // Check date properties in vehicles
      oldGroups.forEach(group => {
        group.vehicles.forEach(vehicle => {
          if (vehicle.estimatedArrival) {
            expect(vehicle.estimatedArrival instanceof Date).toBe(true);
          }
        });
      });

      newGroups.forEach(group => {
        group.vehicles.forEach(vehicle => {
          if (vehicle.estimatedArrival) {
            expect(vehicle.estimatedArrival instanceof Date).toBe(true);
          }
        });
      });
    });
  });

  describe('Property-Based Data Format Tests', () => {
    it('should maintain consistent data types across all option combinations', () => {
      fc.assert(
        fc.property(
          fc.record({
            filterByFavorites: fc.boolean(),
            maxStations: fc.integer({ min: 1, max: 5 }),
            maxVehiclesPerStation: fc.integer({ min: 1, max: 10 }),
            showAllVehiclesPerRoute: fc.boolean()
          }),
          (options: VehicleProcessingOptions) => {
            const { result: oldResult } = renderHook(() => useVehicleProcessingOld(options));
            const { result: newResult } = renderHook(() => useVehicleProcessingNew(options));

            // Both should return valid results
            expect(oldResult.current).toBeDefined();
            expect(newResult.current).toBeDefined();

            // Check array properties
            expect(Array.isArray(oldResult.current.stationVehicleGroups)).toBe(true);
            expect(Array.isArray(newResult.current.stationVehicleGroups)).toBe(true);
            expect(Array.isArray(oldResult.current.favoriteRoutes)).toBe(true);
            expect(Array.isArray(newResult.current.favoriteRoutes)).toBe(true);
            expect(Array.isArray(oldResult.current.allStations)).toBe(true);
            expect(Array.isArray(newResult.current.allStations)).toBe(true);
            expect(Array.isArray(oldResult.current.vehicles)).toBe(true);
            expect(Array.isArray(newResult.current.vehicles)).toBe(true);

            // Check boolean properties
            expect(typeof oldResult.current.isLoading).toBe('boolean');
            expect(typeof newResult.current.isLoading).toBe('boolean');
            expect(typeof oldResult.current.isLoadingStations).toBe('boolean');
            expect(typeof newResult.current.isLoadingStations).toBe('boolean');
            expect(typeof oldResult.current.isLoadingVehicles).toBe('boolean');
            expect(typeof newResult.current.isLoadingVehicles).toBe('boolean');
            expect(typeof oldResult.current.isProcessingVehicles).toBe('boolean');
            expect(typeof newResult.current.isProcessingVehicles).toBe('boolean');

            return true;
          }
        ),
        { numRuns: 25 }
      );
    });

    it('should maintain consistent vehicle structure across all configurations', () => {
      fc.assert(
        fc.property(
          fc.record({
            maxStations: fc.integer({ min: 1, max: 3 }),
            maxVehiclesPerStation: fc.integer({ min: 1, max: 5 })
          }),
          (options: VehicleProcessingOptions) => {
            const { result: oldResult } = renderHook(() => useVehicleProcessingOld(options));
            const { result: newResult } = renderHook(() => useVehicleProcessingNew(options));

            const oldGroups = oldResult.current.stationVehicleGroups;
            const newGroups = newResult.current.stationVehicleGroups;

            // Check structure consistency
            oldGroups.forEach(group => {
              expect(group.station).toBeDefined();
              expect(typeof group.station.distance).toBe('number');
              expect(Array.isArray(group.vehicles)).toBe(true);
              expect(Array.isArray(group.allRoutes)).toBe(true);

              group.vehicles.forEach(vehicle => {
                expect(typeof vehicle.id).toBe('string');
                expect(typeof vehicle.routeId).toBe('string');
                expect(typeof vehicle.minutesAway).toBe('number');
                if (vehicle.estimatedArrival) {
                  expect(vehicle.estimatedArrival instanceof Date).toBe(true);
                }
              });
            });

            newGroups.forEach(group => {
              expect(group.station).toBeDefined();
              expect(typeof group.station.distance).toBe('number');
              expect(Array.isArray(group.vehicles)).toBe(true);
              expect(Array.isArray(group.allRoutes)).toBe(true);

              group.vehicles.forEach(vehicle => {
                expect(typeof vehicle.id).toBe('string');
                expect(typeof vehicle.routeId).toBe('string');
                expect(typeof vehicle.minutesAway).toBe('number');
                if (vehicle.estimatedArrival) {
                  expect(vehicle.estimatedArrival instanceof Date).toBe(true);
                }
              });
            });

            return true;
          }
        ),
        { numRuns: 20 }
      );
    });
  });

  describe('Comprehensive Compatibility Verification', () => {
    it('should pass comprehensive compatibility test suite', async () => {
      const testResults = await compatibilityVerifier.runTestSuite(
        useVehicleProcessingOld,
        useVehicleProcessingNew
      );

      // At least 80% of tests should pass
      const successRate = (testResults.passedTests / testResults.totalTests) * 100;
      expect(successRate).toBeGreaterThanOrEqual(80);

      // Log results for debugging
      console.log(`Compatibility test results: ${testResults.passedTests}/${testResults.totalTests} passed (${successRate.toFixed(1)}%)`);
      
      if (testResults.failedTests > 0) {
        const failedResults = testResults.results.filter(r => !r.passed);
        console.log('Failed tests:', failedResults.map(r => ({
          name: r.testName,
          differences: r.differences.slice(0, 3) // Show first 3 differences
        })));
      }
    });
  });
});