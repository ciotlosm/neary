/**
 * Component compatibility tests for hook migration
 * 
 * These tests verify that existing components work correctly with both
 * old and new hook implementations.
 */

import React from 'react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import { ThemeProvider, createTheme } from '@mui/material/styles';

// Import components that use the hooks
import { StationDisplay } from '../../components/features/StationDisplay/StationDisplay';
import { FavoriteRoutesView } from '../../components/features/FavoriteRoutesView/FavoriteRoutesView';

// Import migration utilities
import { featureFlags, migrationTracker } from './index';

// Create a test theme
const testTheme = createTheme();

// Test wrapper component
const TestWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <ThemeProvider theme={testTheme}>
    {children}
  </ThemeProvider>
);

// Mock all the store dependencies
vi.mock('../../stores/locationStore', () => ({
  useLocationStore: vi.fn(() => ({
    currentLocation: { latitude: 46.7712, longitude: 23.6236 },
    setCurrentLocation: vi.fn(),
    clearLocation: vi.fn()
  }))
}));

vi.mock('../../stores/configStore', () => ({
  useConfigStore: vi.fn(() => ({
    config: {
      agencyId: 'test-agency',
      city: 'Cluj-Napoca',
      homeLocation: { latitude: 46.7712, longitude: 23.6236 },
      workLocation: { latitude: 46.7800, longitude: 23.6300 },
      favoriteBuses: [
        { routeId: '1', routeName: 'Route 1' },
        { routeId: '2', routeName: 'Route 2' }
      ]
    },
    updateConfig: vi.fn(),
    clearConfig: vi.fn()
  }))
}));

// Mock the data layer hooks with realistic data
vi.mock('../data/useStationData', () => ({
  useStationData: vi.fn(() => ({
    data: [
      {
        id: 'station1',
        name: 'Piața Unirii',
        coordinates: { latitude: 46.7712, longitude: 23.6236 }
      },
      {
        id: 'station2',
        name: 'Mănăștur',
        coordinates: { latitude: 46.7800, longitude: 23.6300 }
      }
    ],
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('../data/useVehicleData', () => ({
  useVehicleData: vi.fn(() => ({
    data: [
      {
        id: 'vehicle1',
        routeId: '1',
        tripId: 'trip1',
        label: '101',
        position: { latitude: 46.7712, longitude: 23.6236 },
        timestamp: new Date(),
        speed: 25,
        isWheelchairAccessible: true,
        isBikeAccessible: false
      },
      {
        id: 'vehicle2',
        routeId: '2',
        tripId: 'trip2',
        label: '102',
        position: { latitude: 46.7800, longitude: 23.6300 },
        timestamp: new Date(),
        speed: 30,
        isWheelchairAccessible: false,
        isBikeAccessible: true
      }
    ],
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('../data/useRouteData', () => ({
  useRouteData: vi.fn(() => ({
    data: [
      {
        id: '1',
        routeName: 'Route 1',
        routeDesc: 'Piața Unirii - Mănăștur',
        type: 'bus'
      },
      {
        id: '2',
        routeName: 'Route 2',
        routeDesc: 'Centru - Zorilor',
        type: 'trolleybus'
      }
    ],
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

vi.mock('../data/useStopTimesData', () => ({
  useStopTimesData: vi.fn(() => ({
    data: [
      {
        tripId: 'trip1',
        stopId: 'station1',
        sequence: 1,
        arrivalTime: '10:00:00',
        departureTime: '10:01:00'
      },
      {
        tripId: 'trip1',
        stopId: 'station2',
        sequence: 2,
        arrivalTime: '10:15:00',
        departureTime: '10:16:00'
      },
      {
        tripId: 'trip2',
        stopId: 'station2',
        sequence: 1,
        arrivalTime: '10:05:00',
        departureTime: '10:06:00'
      }
    ],
    isLoading: false,
    error: null,
    refetch: vi.fn(),
    lastUpdated: new Date()
  }))
}));

// Mock processing layer hooks
vi.mock('../processing/useVehicleFiltering', () => ({
  useVehicleFiltering: vi.fn((vehicles, options) => ({
    filteredVehicles: vehicles.filter(v => 
      !options.filterByFavorites || 
      options.favoriteRoutes?.some((fav: any) => fav.routeId === v.routeId)
    ),
    filterStats: {
      totalVehicles: vehicles.length,
      filteredCount: vehicles.length,
      appliedFilters: options.filterByFavorites ? ['favorites'] : []
    }
  }))
}));

vi.mock('../processing/useVehicleGrouping', () => ({
  useVehicleGrouping: vi.fn((vehicles, stations, userLocation, options) => ({
    stationGroups: stations.slice(0, options.maxStations || 2).map((station: any, index: number) => ({
      station: { station, distance: 100 + index * 50 },
      vehicles: vehicles.slice(index, index + (options.maxVehiclesPerStation || 5)).map((vehicle: any) => ({
        ...vehicle,
        minutesAway: 5 + index * 2,
        estimatedArrival: new Date(Date.now() + (5 + index * 2) * 60000)
      })),
      allRoutes: vehicles.map((v: any) => ({
        routeId: v.routeId,
        routeName: `Route ${v.routeId}`,
        vehicleCount: 1
      }))
    })),
    groupingStats: {
      totalStations: stations.length,
      groupedStations: Math.min(stations.length, options.maxStations || 2),
      totalVehicles: vehicles.length
    }
  }))
}));

// Mock other dependencies
vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  }
}));

vi.mock('../../utils/performance', () => ({
  withPerformanceMonitoring: vi.fn((component) => component)
}));

describe('Component Compatibility Tests', () => {
  beforeEach(() => {
    // Reset feature flags and migration state
    featureFlags.disableAllFeatures();
    migrationTracker.clear();
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('StationDisplay Component', () => {
    it('should render correctly with old hooks (feature flags disabled)', async () => {
      // Ensure old hooks are used
      featureFlags.disableAllFeatures();

      render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      // Wait for component to render
      await waitFor(() => {
        // Should show station information
        expect(screen.getByText(/station/i)).toBeInTheDocument();
      });

      // Should not throw any errors
      expect(() => {
        render(
          <TestWrapper>
            <StationDisplay />
          </TestWrapper>
        );
      }).not.toThrow();
    });

    it('should render correctly with new hooks (feature flags enabled)', async () => {
      // Enable new hooks for StationDisplay
      featureFlags.enableComponent('StationDisplay');

      render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      // Wait for component to render
      await waitFor(() => {
        // Should show station information
        expect(screen.getByText(/station/i)).toBeInTheDocument();
      });

      // Should not throw any errors
      expect(() => {
        render(
          <TestWrapper>
            <StationDisplay />
          </TestWrapper>
        );
      }).not.toThrow();
    });

    it('should produce identical output with both hook implementations', async () => {
      // Render with old hooks
      featureFlags.disableAllFeatures();
      const { container: oldContainer } = render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(oldContainer.textContent).toBeTruthy();
      });

      const oldContent = oldContainer.textContent;

      // Render with new hooks
      featureFlags.enableComponent('StationDisplay');
      const { container: newContainer } = render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(newContainer.textContent).toBeTruthy();
      });

      const newContent = newContainer.textContent;

      // Content should be very similar (allowing for minor timing differences)
      expect(newContent).toBeTruthy();
      expect(oldContent).toBeTruthy();
      
      // Both should contain key elements
      expect(oldContent).toMatch(/station/i);
      expect(newContent).toMatch(/station/i);
    });

    it('should handle loading states consistently', async () => {
      // Mock loading state
      const mockUseStationData = vi.fn(() => ({
        data: null,
        isLoading: true,
        error: null,
        refetch: vi.fn(),
        lastUpdated: null
      }));

      vi.doMock('../data/useStationData', () => ({
        useStationData: mockUseStationData
      }));

      // Test with old hooks
      featureFlags.disableAllFeatures();
      const { container: oldContainer } = render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      // Test with new hooks
      featureFlags.enableComponent('StationDisplay');
      const { container: newContainer } = render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      // Both should handle loading state
      expect(oldContainer).toBeTruthy();
      expect(newContainer).toBeTruthy();
    });
  });

  describe('FavoriteRoutesView Component', () => {
    it('should render correctly with old hooks (feature flags disabled)', async () => {
      // Ensure old hooks are used
      featureFlags.disableAllFeatures();

      render(
        <TestWrapper>
          <FavoriteRoutesView />
        </TestWrapper>
      );

      // Wait for component to render
      await waitFor(() => {
        // Component should render without errors
        expect(document.body).toBeInTheDocument();
      });

      // Should not throw any errors
      expect(() => {
        render(
          <TestWrapper>
            <FavoriteRoutesView />
          </TestWrapper>
        );
      }).not.toThrow();
    });

    it('should render correctly with new hooks (feature flags enabled)', async () => {
      // Enable new hooks for FavoriteRoutesView
      featureFlags.enableComponent('FavoriteRoutesView');

      render(
        <TestWrapper>
          <FavoriteRoutesView />
        </TestWrapper>
      );

      // Wait for component to render
      await waitFor(() => {
        // Component should render without errors
        expect(document.body).toBeInTheDocument();
      });

      // Should not throw any errors
      expect(() => {
        render(
          <TestWrapper>
            <FavoriteRoutesView />
          </TestWrapper>
        );
      }).not.toThrow();
    });

    it('should handle favorites filtering consistently', async () => {
      // Both implementations should filter by favorites when filterByFavorites is true
      
      // Test with old hooks
      featureFlags.disableAllFeatures();
      const { container: oldContainer } = render(
        <TestWrapper>
          <FavoriteRoutesView />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(oldContainer.textContent).toBeTruthy();
      });

      // Test with new hooks
      featureFlags.enableComponent('FavoriteRoutesView');
      const { container: newContainer } = render(
        <TestWrapper>
          <FavoriteRoutesView />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(newContainer.textContent).toBeTruthy();
      });

      // Both should render content
      expect(oldContainer.textContent).toBeTruthy();
      expect(newContainer.textContent).toBeTruthy();
    });
  });

  describe('Migration Behavior', () => {
    it('should track migration usage correctly', async () => {
      // Enable migration tracking
      featureFlags.updateFlags({
        enableMigrationLogging: true,
        enablePerformanceMonitoring: true
      });

      // Enable new hooks for one component
      featureFlags.enableComponent('StationDisplay');

      render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(document.body).toBeInTheDocument();
      });

      // Migration tracker should have recorded the usage
      const summary = migrationTracker.getMigrationSummary();
      expect(summary.totalMigrations).toBeGreaterThanOrEqual(0);
    });

    it('should handle gradual rollout correctly', async () => {
      // Enable gradual rollout
      featureFlags.updateFlags({
        enableGradualRollout: true
      });

      // Enable only StationDisplay
      featureFlags.enableComponent('StationDisplay');

      // StationDisplay should use new hooks
      expect(featureFlags.isComponentEnabled('StationDisplay')).toBe(true);

      // FavoriteRoutesView should use old hooks
      expect(featureFlags.isComponentEnabled('FavoriteRoutesView')).toBe(false);

      // Both components should render correctly
      const stationDisplay = render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      const favoriteRoutesView = render(
        <TestWrapper>
          <FavoriteRoutesView />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(stationDisplay.container).toBeTruthy();
        expect(favoriteRoutesView.container).toBeTruthy();
      });
    });

    it('should handle rollback correctly', async () => {
      // First enable new hooks
      featureFlags.enableAllFeatures();

      render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(document.body).toBeInTheDocument();
      });

      // Then rollback to old hooks
      featureFlags.disableAllFeatures();

      render(
        <TestWrapper>
          <StationDisplay />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(document.body).toBeInTheDocument();
      });

      // Should work correctly in both cases
      expect(featureFlags.isComponentEnabled('StationDisplay')).toBe(false);
    });
  });

  describe('Error Handling', () => {
    it('should handle hook errors gracefully', async () => {
      // Mock an error in the data layer
      vi.doMock('../data/useStationData', () => ({
        useStationData: vi.fn(() => ({
          data: null,
          isLoading: false,
          error: new Error('Test error'),
          refetch: vi.fn(),
          lastUpdated: null
        }))
      }));

      // Both old and new implementations should handle errors
      featureFlags.disableAllFeatures();
      expect(() => {
        render(
          <TestWrapper>
            <StationDisplay />
          </TestWrapper>
        );
      }).not.toThrow();

      featureFlags.enableComponent('StationDisplay');
      expect(() => {
        render(
          <TestWrapper>
            <StationDisplay />
          </TestWrapper>
        );
      }).not.toThrow();
    });

    it('should fallback to old hooks on new hook failure', async () => {
      // Enable fallback behavior
      featureFlags.enableComponent('StationDisplay');

      // Component should still render even if new hooks have issues
      expect(() => {
        render(
          <TestWrapper>
            <StationDisplay />
          </TestWrapper>
        );
      }).not.toThrow();
    });
  });

  describe('Performance', () => {
    it('should not significantly impact render performance', async () => {
      const iterations = 5;
      
      // Measure old hook performance
      featureFlags.disableAllFeatures();
      const oldTimes: number[] = [];
      
      for (let i = 0; i < iterations; i++) {
        const startTime = performance.now();
        const { unmount } = render(
          <TestWrapper>
            <StationDisplay />
          </TestWrapper>
        );
        await waitFor(() => expect(document.body).toBeInTheDocument());
        const endTime = performance.now();
        oldTimes.push(endTime - startTime);
        unmount();
      }

      // Measure new hook performance
      featureFlags.enableComponent('StationDisplay');
      const newTimes: number[] = [];
      
      for (let i = 0; i < iterations; i++) {
        const startTime = performance.now();
        const { unmount } = render(
          <TestWrapper>
            <StationDisplay />
          </TestWrapper>
        );
        await waitFor(() => expect(document.body).toBeInTheDocument());
        const endTime = performance.now();
        newTimes.push(endTime - startTime);
        unmount();
      }

      const oldAvg = oldTimes.reduce((sum, time) => sum + time, 0) / oldTimes.length;
      const newAvg = newTimes.reduce((sum, time) => sum + time, 0) / newTimes.length;

      // New implementation should not be more than 50% slower
      expect(newAvg).toBeLessThan(oldAvg * 1.5);

      console.log(`Render performance - Old: ${oldAvg.toFixed(2)}ms, New: ${newAvg.toFixed(2)}ms`);
    });
  });
});